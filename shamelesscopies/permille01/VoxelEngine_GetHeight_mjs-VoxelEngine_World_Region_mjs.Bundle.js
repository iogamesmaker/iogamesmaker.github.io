"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkElectronProject"] = self["webpackChunkElectronProject"] || []).push([["VoxelEngine_GetHeight_mjs-VoxelEngine_World_Region_mjs"],{

/***/ "./VoxelEngine/Libraries/TooLoud/src/Worley.js":
/*!*****************************************************!*\
  !*** ./VoxelEngine/Libraries/TooLoud/src/Worley.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Worley {\n    constructor(seed = 3000) {\n        this._seedValue = seed;\n\n        this.setSeed = this.setSeed.bind(this);\n        this.noise = this.noise.bind(this);\n        this.Euclidean = this.Euclidean.bind(this);\n        this.Manhattan = this.Manhattan.bind(this);\n    }\n\n    static xorshift(value) {\n        let x = value ^ (value >> 12);\n        x = x ^ (x << 25);\n        x = x ^ (x >> 27);\n        return x * 2;\n    }\n\n    static xorshift31(value) {\n        //let x = value ^ (value >> 12);\n        //x = x ^ (x << 25);\n        //x = x ^ (x >> 27);\n        value ^= value >>> 12;\n        value ^= value << 25;\n        value ^= value >>> 27;\n        return value >>> 0;//((value + 0x5c1d868c) ^ value) >>> 0;\n    }\n\n    static hash(i, j, k) {\n        return (((((2166136261 ^ i) * 16777619) ^ j) * 16777619) ^ k) * 16777619 & 0xffffffff;\n    }\n    static hash2(i, j) {\n        return ((((2166136261 ^ i) * 16777619) ^ j)) * 16777619;\n    }\n\n    static d(p1, p2) {\n        return [p1.x - p2.x, p1.y - p2.y, p1.z - p2.z];\n    }\n\n    static EuclideanDistance(p1, p2) {\n        return Worley.d(p1, p2).reduce((sum, x) => sum + (x * x), 0);\n    }\n\n    static ManhattanDistance(p1, p2) {\n        return Worley.d(p1, p2).reduce((sum, x) => sum + Math.abs(x), 0)\n    }\n\n    static probLookup(value) {\n        value = value & 0xffffffff;\n        //debugger;\n        if (value < 393325350) return 1;\n        if (value < 1022645910) return 2;\n        if (value < 1861739990) return 3;\n        if (value < 2700834071) return 4;\n        if (value < 3372109335) return 5;\n        if (value < 3819626178) return 6;\n        if (value < 4075350088) return 7;\n        if (value < 4203212043) return 8;\n        return 9;\n    }\n\n    static insert(arr, value) {\n        let temp;\n        for (let i = arr.length - 1; i >= 0; i--) {\n            if (value > arr[i]) break;\n            temp = arr[i];\n            arr[i] = value;\n            if (i + 1 < arr.length) arr[i + 1] = temp;\n        }\n    }\n\n    noise(input, distanceFunc) {\n        let lastRandom,\n            numberFeaturePoints,\n            randomDiff = { x: 0, y: 0, z: 0 },\n            featurePoint = { x: 0, y: 0, z: 0 };\n        let cubeX, cubeY, cubeZ;\n        let distanceArray = [9999999, 9999999, 9999999];\n\n        for (let i = -1; i < 2; ++i)\n            for (let j = -1; j < 2; ++j)\n                for (let k = -1; k < 2; ++k) {\n                    cubeX = Math.floor(input.x) + i;\n                    cubeY = Math.floor(input.y) + j;\n                    cubeZ = Math.floor(input.z) + k;\n                    lastRandom = Worley.xorshift(\n                        Worley.hash(\n                            (cubeX + this._seedValue) & 0xffffffff,\n                            (cubeY) & 0xffffffff,\n                            (cubeZ) & 0xffffffff\n                        )\n                    );\n                    numberFeaturePoints = Worley.probLookup(lastRandom);\n                    for (let l = 0; l < numberFeaturePoints; ++l) {\n                        lastRandom = Worley.xorshift(lastRandom);\n                        randomDiff.X = lastRandom / 0x100000000;\n\n                        lastRandom = Worley.xorshift(lastRandom);\n                        randomDiff.Y = lastRandom / 0x100000000;\n\n                        lastRandom = Worley.xorshift(lastRandom);\n                        randomDiff.Z = lastRandom / 0x100000000;\n\n                        featurePoint = {\n                            x: randomDiff.X + cubeX,\n                            y: randomDiff.Y + cubeY,\n                            z: randomDiff.Z + cubeZ\n                        };\n                        Worley.insert(distanceArray, distanceFunc(input, featurePoint));\n                    }\n                }\n\n        return distanceArray;//.map(x => x < 0 ? 0 : x > 1 ? 1 : x );\n    }\n\n    FasterNoise(X, Y) {\n        const Seed = this._seedValue;\n        let Distance = Infinity;\n\n        for (let i = -1; i < 2; ++i) for (let j = -1; j < 2; ++j){\n            const TileX = Math.floor(X) + i;\n            const TileY = Math.floor(Y) + j;\n            let LastRandom = Worley.xorshift31(Worley.hash2(TileX ^ Seed, TileY));\n\n            const Points = [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4][LastRandom & 15];\n            for (let l = 0; l < Points; ++l){\n                LastRandom = Worley.xorshift31(LastRandom);\n                const PointX = LastRandom / 0xffffffff + TileX;\n                LastRandom = Worley.xorshift31(LastRandom);\n                const PointY = LastRandom / 0xffffffff + TileY;\n                LastRandom = Worley.xorshift31(LastRandom);\n                const PointZ = LastRandom / 0xffffffff;\n\n                let New = (X - PointX) ** 2 + (Y - PointY) ** 2 + PointZ ** 2;\n                if(Distance > New) Distance = New;\n            }\n        }\n        return Distance;\n    }\n\n    FasterNoise2(X, Y){\n\n    }\n    static EuclideanDistance2D(p1, p2) {\n        return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;\n    }\n\n    setSeed(seed = 3000) {\n        this._seedValue = seed;\n    }\n\n    Euclidean(x, y, z) {\n        return this.noise({ x:x, y:y, z:z }, Worley.EuclideanDistance);\n    }\n\n    Manhattan(x, y, z) {\n        return this.noise({ x:x, y:y, z:z }, Worley.ManhattanDistance);\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Worley);\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Libraries/TooLoud/src/Worley.js?");

/***/ }),

/***/ "./VoxelEngine/Simplex.js":
/*!********************************!*\
  !*** ./VoxelEngine/Simplex.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n * A speed-improved perlin and simplex noise algorithms for 2D.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n * Converted to Javascript by Joseph Gentle.\r\n *\r\n * Version 2012-03-09\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n *\r\n */\r\n///https://github.com/josephg/noisejs/blob/master/perlin.js\r\n\r\nconst Noise = {};\r\n(function(){\r\n  var module = Noise;\r\n\r\n  function Grad(x, y, z) {\r\n    this.x = x; this.y = y; this.z = z;\r\n  }\r\n\r\n  Grad.prototype.dot2 = function(x, y) {\r\n    return this.x*x + this.y*y;\r\n  };\r\n\r\n  Grad.prototype.dot3 = function(x, y, z) {\r\n    return this.x*x + this.y*y + this.z*z;\r\n  };\r\n\r\n  var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\r\n               new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\r\n               new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\r\n\r\n  var p = [151,160,137,91,90,15,\r\n  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\r\n  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\r\n  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\r\n  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\r\n  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\r\n  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\r\n  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\r\n  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\r\n  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\r\n  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\r\n  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\r\n  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\r\n  // To remove the need for index wrapping, double the permutation table length\r\n  var perm = new Array(512);\r\n  var gradP = new Array(512);\r\n\r\n  // This isn't a very good seeding function, but it works ok. It supports 2^16\r\n  // different seed values. Write something better if you need more seeds.\r\n  module.seed = function(seed) {\r\n    if(seed > 0 && seed < 1) {\r\n      // Scale the seed out\r\n      seed *= 65536;\r\n    }\r\n\r\n    seed = Math.floor(seed);\r\n    if(seed < 256) {\r\n      seed |= seed << 8;\r\n    }\r\n\r\n    for(var i = 0; i < 256; i++) {\r\n      var v;\r\n      if (i & 1) {\r\n        v = p[i] ^ (seed & 255);\r\n      } else {\r\n        v = p[i] ^ ((seed>>8) & 255);\r\n      }\r\n\r\n      perm[i] = perm[i + 256] = v;\r\n      gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n    }\r\n  };\r\n\r\n  module.seed(0);\r\n\r\n  /*\r\n  for(var i=0; i<256; i++) {\r\n    perm[i] = perm[i + 256] = p[i];\r\n    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\r\n  }*/\r\n\r\n  // Skewing and unskewing factors for 2, 3, and 4 dimensions\r\n  var F2 = 0.5*(Math.sqrt(3)-1);\r\n  var G2 = (3-Math.sqrt(3))/6;\r\n\r\n  var F3 = 1/3;\r\n  var G3 = 1/6;\r\n\r\n  // 2D simplex noise\r\n  module.simplex2 = function(xin, yin) {\r\n    var n0, n1, n2; // Noise contributions from the three corners\r\n    // Skew the input space to determine which simplex cell we're in\r\n    var s = (xin+yin)*F2; // Hairy factor for 2D\r\n    var i = Math.floor(xin+s);\r\n    var j = Math.floor(yin+s);\r\n    var t = (i+j)*G2;\r\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n    var y0 = yin-j+t;\r\n    // For the 2D case, the simplex shape is an equilateral triangle.\r\n    // Determine which simplex we are in.\r\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n      i1=1; j1=0;\r\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n      i1=0; j1=1;\r\n    }\r\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n    // c = (3-sqrt(3))/6\r\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n    var y1 = y0 - j1 + G2;\r\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n    var y2 = y0 - 1 + 2 * G2;\r\n    // Work out the hashed gradient indices of the three simplex corners\r\n    i &= 255;\r\n    j &= 255;\r\n    var gi0 = gradP[i+perm[j]];\r\n    var gi1 = gradP[i+i1+perm[j+j1]];\r\n    var gi2 = gradP[i+1+perm[j+1]];\r\n    // Calculate the contribution from the three corners\r\n    var t0 = 0.5 - x0*x0-y0*y0;\r\n    if(t0<0) {\r\n      n0 = 0;\r\n    } else {\r\n      t0 *= t0;\r\n      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\r\n    }\r\n    var t1 = 0.5 - x1*x1-y1*y1;\r\n    if(t1<0) {\r\n      n1 = 0;\r\n    } else {\r\n      t1 *= t1;\r\n      n1 = t1 * t1 * gi1.dot2(x1, y1);\r\n    }\r\n    var t2 = 0.5 - x2*x2-y2*y2;\r\n    if(t2<0) {\r\n      n2 = 0;\r\n    } else {\r\n      t2 *= t2;\r\n      n2 = t2 * t2 * gi2.dot2(x2, y2);\r\n    }\r\n    // Add contributions from each corner to get the final noise value.\r\n    // The result is scaled to return values in the interval [-1,1].\r\n    //return 70 * n0 + n1 + n2;\r\n\t///return 70 * (n0 + n1 + n2);\r\n\treturn 70 * (n0 + n1 + n2);\r\n  };\r\n\r\n  // 3D simplex noise\r\n  module.simplex3 = function(xin, yin, zin) {\r\n    var n0, n1, n2, n3; // Noise contributions from the four corners\r\n\r\n    // Skew the input space to determine which simplex cell we're in\r\n    var s = (xin+yin+zin)*F3; // Hairy factor for 2D\r\n    var i = Math.floor(xin+s);\r\n    var j = Math.floor(yin+s);\r\n    var k = Math.floor(zin+s);\r\n\r\n    var t = (i+j+k)*G3;\r\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n    var y0 = yin-j+t;\r\n    var z0 = zin-k+t;\r\n\r\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n    // Determine which simplex we are in.\r\n    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n    if(x0 >= y0) {\r\n      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\r\n      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\r\n      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\r\n    } else {\r\n      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\r\n      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\r\n      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\r\n    }\r\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n    // c = 1/6.\r\n    var x1 = x0 - i1 + G3; // Offsets for second corner\r\n    var y1 = y0 - j1 + G3;\r\n    var z1 = z0 - k1 + G3;\r\n\r\n    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\r\n    var y2 = y0 - j2 + 2 * G3;\r\n    var z2 = z0 - k2 + 2 * G3;\r\n\r\n    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\r\n    var y3 = y0 - 1 + 3 * G3;\r\n    var z3 = z0 - 1 + 3 * G3;\r\n\r\n    // Work out the hashed gradient indices of the four simplex corners\r\n    i &= 255;\r\n    j &= 255;\r\n    k &= 255;\r\n    var gi0 = gradP[i+   perm[j+   perm[k   ]]];\r\n    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\r\n    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\r\n    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\r\n\r\n    // Calculate the contribution from the four corners\r\n    var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\r\n    if(t0<0) {\r\n      n0 = 0;\r\n    } else {\r\n      t0 *= t0;\r\n      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\r\n    }\r\n    var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\r\n    if(t1<0) {\r\n      n1 = 0;\r\n    } else {\r\n      t1 *= t1;\r\n      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\r\n    }\r\n    var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\r\n    if(t2<0) {\r\n      n2 = 0;\r\n    } else {\r\n      t2 *= t2;\r\n      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\r\n    }\r\n    var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\r\n    if(t3<0) {\r\n      n3 = 0;\r\n    } else {\r\n      t3 *= t3;\r\n      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\r\n    }\r\n    // Add contributions from each corner to get the final noise value.\r\n    // The result is scaled to return values in the interval [-1,1].\r\n    return 32 * (n0 + n1 + n2 + n3);\r\n\r\n  };\r\n\r\n  // ##### Perlin noise stuff\r\n\r\n  function fade(t) {\r\n    return t*t*t*(t*(t*6-15)+10);\r\n  }\r\n\r\n  function lerp(a, b, t) {\r\n    return (1-t)*a + t*b;\r\n  }\r\n\r\n  // 2D Perlin Noise\r\n  module.perlin2 = function(x, y) {\r\n    // Find unit grid cell containing point\r\n    var X = Math.floor(x), Y = Math.floor(y);\r\n    // Get relative xy coordinates of point within that cell\r\n    x = x - X; y = y - Y;\r\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n    X = X & 255; Y = Y & 255;\r\n\r\n    // Calculate noise contributions from each of the four corners\r\n    var n00 = gradP[X+perm[Y]].dot2(x, y);\r\n    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\r\n    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\r\n    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\r\n\r\n    // Compute the fade curve value for x\r\n    var u = fade(x);\r\n\r\n    // Interpolate the four results\r\n    return lerp(\r\n        lerp(n00, n10, u),\r\n        lerp(n01, n11, u),\r\n       fade(y));\r\n  };\r\n\r\n  // 3D Perlin Noise\r\n  module.perlin3 = function(x, y, z) {\r\n    // Find unit grid cell containing point\r\n    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\r\n    // Get relative xyz coordinates of point within that cell\r\n    x = x - X; y = y - Y; z = z - Z;\r\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n    X = X & 255; Y = Y & 255; Z = Z & 255;\r\n\r\n    // Calculate noise contributions from each of the eight corners\r\n    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\r\n    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\r\n    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\r\n    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\r\n    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\r\n    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\r\n    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\r\n    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\r\n\r\n    // Compute the fade curve value for x, y, z\r\n    var u = fade(x);\r\n    var v = fade(y);\r\n    var w = fade(z);\r\n\r\n    // Interpolate\r\n    return lerp(\r\n        lerp(\r\n          lerp(n000, n100, u),\r\n          lerp(n001, n101, u), w),\r\n        lerp(\r\n          lerp(n010, n110, u),\r\n          lerp(n011, n111, u), w),\r\n       v);\r\n  };\r\n\r\n})();\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Noise);\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Simplex.js?");

/***/ }),

/***/ "./VoxelEngine/GetHeight.mjs":
/*!***********************************!*\
  !*** ./VoxelEngine/GetHeight.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GetHeight\": () => (/* binding */ GetHeight),\n/* harmony export */   \"ReSeed\": () => (/* binding */ ReSeed),\n/* harmony export */   \"_GetHeight\": () => (/* binding */ _GetHeight)\n/* harmony export */ });\n/* harmony import */ var _Simplex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Simplex.js */ \"./VoxelEngine/Simplex.js\");\n/* harmony import */ var _Libraries_TooLoud_src_Worley_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Libraries/TooLoud/src/Worley.js */ \"./VoxelEngine/Libraries/TooLoud/src/Worley.js\");\n\r\n\r\nconst WorleyNoise = new _Libraries_TooLoud_src_Worley_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\r\n\r\n//Weighting functions:\r\n//https://www.desmos.com/calculator/jc40rsanua\r\n\r\nfunction SerpentineWeightingFunction(Value, Exponent){\r\n  const Intermediate = (2 * Value - 1) / ((2 * Value - 1) ** 2 + 1);\r\n  return (Math.sign(Intermediate) * Math.abs(Intermediate) ** Exponent + 0.5 ** Exponent) / Exponent ** (-Exponent);\r\n}\r\n\r\nfunction BiasedSerpentineWeightingFunction(Value){\r\n  const Intermediate = (2 * Value - 1) / ((2 * Value - 1) ** 2 + 1);\r\n  return Math.sign(Intermediate) * (1. - (1. - (2. * Math.abs(Intermediate))) ** (1. + Value)) * .5 + .5;\r\n}\r\n\r\nfunction BetterSerpentineWeightingFunction(Value, Exponent){\r\n  const Intermediate = (2 * Value - 1) / ((2 * Value - 1) ** 2 + 1);\r\n  return Math.sign(Intermediate) * (1. - (1. - (2. * Math.abs(Intermediate))) ** Exponent) * .5 + .5;\r\n}\r\n\r\nfunction ExponentialWeightingFunction(Value, Exponent){\r\n  return Math.expm1(Math.pow(Value, Exponent)) / Math.expm1(1);\r\n}\r\n\r\nconst SerpentineWeighting = [];\r\nfor(let i = 0; i < 150; i++){\r\n  SerpentineWeighting[i] = new Float32Array(501);\r\n  for(let j = 0, Weighting = SerpentineWeighting[i]; j < 501; j++){\r\n    Weighting[j] = SerpentineWeightingFunction(j / 500, i / 150);\r\n  }\r\n}\r\n\r\nconst BetterSerpentineWeighting = [];\r\nfor(let i = 0; i < 150; i++){\r\n  BetterSerpentineWeighting[i] = new Float32Array(501);\r\n  for(let j = 0, Weighting = BetterSerpentineWeighting[i]; j < 501; j++){\r\n    Weighting[j] = BetterSerpentineWeightingFunction(j / 2000, i / 150);\r\n  }\r\n}\r\n\r\nconst ExponentialWeighting = [];\r\nfor(let i = 250; i < 450; i++){\r\n  ExponentialWeighting[i] = new Float32Array(771);\r\n  for(let j = 0, Weighting = ExponentialWeighting[i]; j < 771; j++){\r\n    Weighting[j] = ExponentialWeightingFunction(j / 500, i / 150);\r\n  }\r\n}\r\n\r\n//Less expensive approximation functions:\r\n\r\nfunction GetSerpentineWeightingAt(Value, Exponent){\r\n  let ValueIndex = Value * 100;\r\n  let ExponentIndex = Exponent * 2000;\r\n  let ValueOffset = ValueIndex - (ValueIndex >>= 0);\r\n  let ExponentOffset = ExponentIndex - (ExponentIndex >>= 0);\r\n  //Precalculate derivatives?\r\n  let CurrentValue = SerpentineWeighting[ValueIndex][ExponentIndex];\r\n  return CurrentValue + (ValueOffset * (SerpentineWeighting[ValueIndex + 1][ExponentIndex] - CurrentValue) + ExponentOffset * (SerpentineWeighting[ValueIndex][ExponentIndex + 1] - CurrentValue));\r\n}\r\n\r\nfunction GetBetterSerpentineWeightingAt(Value, Exponent){\r\n  let ValueIndex = Value * 100;\r\n  let ExponentIndex = Exponent * 500;\r\n  let ValueOffset = ValueIndex - (ValueIndex >>= 0);\r\n  let ExponentOffset = ExponentIndex - (ExponentIndex >>= 0);\r\n  //Precalculate derivatives?\r\n  let CurrentValue = BetterSerpentineWeighting[ValueIndex][ExponentIndex];\r\n  return CurrentValue + (ValueOffset * (BetterSerpentineWeighting[ValueIndex + 1][ExponentIndex] - CurrentValue) + ExponentOffset * (BetterSerpentineWeighting[ValueIndex][ExponentIndex + 1] - CurrentValue));\r\n}\r\n\r\nfunction GetExponentialWeightingAt(Value, Exponent){\r\n  let ValueIndex = Value * 100;\r\n  let ExponentIndex = Exponent * 500;\r\n  let ValueOffset = ValueIndex - (ValueIndex >>= 0);\r\n  let ExponentOffset = ExponentIndex - (ExponentIndex >>= 0);\r\n  //Precalculate derivatives?\r\n  let CurrentValue = ExponentialWeighting[ValueIndex][ExponentIndex];\r\n  return CurrentValue + (ValueOffset * (ExponentialWeighting[ValueIndex + 1][ExponentIndex] - CurrentValue) + ExponentOffset * (ExponentialWeighting[ValueIndex][ExponentIndex + 1] - CurrentValue));\r\n}\r\n\r\nfunction GetDerivedArcTangentWeightingAt(Value){\r\n  return 1 / (Value ** 2 + 1);\r\n}\r\n\r\nfunction WeightTowards(PeakX, Distribution, Exponent){\r\n  return function(X){\r\n    return GetDerivedArcTangentWeightingAt((X - PeakX) / Distribution) ** Exponent;\r\n  };\r\n}\r\n\r\nfunction GetSharpWeightingAt(Value){\r\n  const z = 1;\r\n  const f = 1;\r\n  return (z ** 2 + 1) / ((Math.abs(f * Value) + z) ** 2 + 1);\r\n}\r\n\r\nfunction GetAsymmetricWeightingAt1(Value){\r\n  return 2. / (1. + (Math.abs(((2. - Math.sign(Value)) * Value) ** (1.75 + Math.sign(Value) * .75)) + 1.) ** 2.);\r\n}\r\n\r\nfunction GetAsymmetricWeightingAt(Value){\r\n  return 2. / (1. + (Math.abs((2. - 3. * Math.sign(Value)) * Value) + 1.) ** 2.);\r\n}\r\n\r\nfunction WeightTowardsSharp(PeakX, Distribution){\r\n  return function(X){\r\n    return GetSharpWeightingAt((X - PeakX) / Distribution);\r\n  };\r\n}\r\n\r\nfunction WeightTowardsAsymmetric(PeakX, Distribution){\r\n  return function(X){\r\n    return GetAsymmetricWeightingAt((X - PeakX) / Distribution);\r\n  };\r\n}\r\n\r\nfunction GetRepeatingSharpWeightingAt(Value){\r\n  return 1 - Math.abs(Math.sin(Value));\r\n}\r\n\r\nfunction WeightTowardsRepeatingSharp(PeakX, Distribution){\r\n  return function(X){\r\n    return GetRepeatingSharpWeightingAt((X - PeakX) / Distribution);\r\n  };\r\n}\r\n\r\nfunction GetRepeatingSharpWeightingAt2(Value){\r\n  return 1 - Math.abs(Math.sin(.25 * Value));\r\n}\r\n\r\nfunction WeightTowardsRepeatingSharp2(PeakX, Distribution){\r\n  return function(X){\r\n    return GetRepeatingSharpWeightingAt2((X - PeakX) / Distribution);\r\n  };\r\n}\r\n\r\nlet RockyWeighting = WeightTowards(1000, 200, 1);\r\nlet SmoothShoreWeighting = WeightTowards(-0, 30, 1);\r\nlet MountainWeighting = WeightTowards(300, 200, 1);\r\nlet SharperMountainWeighting = WeightTowards(300, 50, 1);\r\nlet OtherMountainWeighting = WeightTowards(1200, 300, 1);\r\nlet SmootherValleyWeighting = WeightTowards(0, 150, 1);\r\nlet OneWeighting = WeightTowards(1.02, 0.17, 1);\r\nlet OneSmallerWeighting = WeightTowards(1.01, 0.05, 1);\r\n\r\nlet Weighting150 = WeightTowardsSharp(150, 20);\r\nlet Weighting100 = WeightTowardsSharp(100, 25);\r\n\r\nlet Things = WeightTowardsRepeatingSharp(0, 0.1);\r\n\r\nlet Cliffs1 = WeightTowardsRepeatingSharp(0., .0251);\r\nconst Cliffs2 = WeightTowardsRepeatingSharp2(0., .00251);\r\n\r\n\r\nconst Weighting1 = WeightTowards(.47, .12, .57);\r\nconst Weighting2 = WeightTowardsSharp(.4, .04);\r\n\r\nconst Weighting15 = WeightTowardsSharp(.15, .0014);\r\n\r\nfunction _GetHeight(X, Z){\r\n  //return X / 140.;//0.;//(X + Z) / 6. + 64.;//128.;//254. + //\r\n  X *= .5;\r\n  Z *= .5;\r\n\r\n  let Smoothness = GetSerpentineWeightingAt(1.4, _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 10000, Z / 10000, 1536) / 2 + 0.5);\r\n  let FlatLevel = (_Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 30000, Z / 30000, 1536) / 2 + 0.5) * 200;\r\n\r\n  let OctaveSum = 0;\r\n  for(let i = 1; i < 9; i++){\r\n    OctaveSum += _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 2 ** (1.08 * i + 3), Z / 2 ** (1.08 * i + 3), 1536) * 2 ** i;\r\n  }\r\n\r\n  let Mountain = (1 - Math.abs( (Math.sin(Math.PI * (_Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 2500, Z / 2500, 1100) - 0.5)) / 2 + 0.5) ** 0.5 ));\r\n\r\n  let OtherMountain = (1 - Math.abs( (Math.sin(Math.PI * (_Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 12500, Z / 12500, 1100) - 0.5)) / 2 + 0.5) ** 0.5 ));\r\n  OtherMountain *= 0.7 * OneWeighting(OtherMountain) + 0.3 * OneSmallerWeighting(OtherMountain);\r\n\r\n  OctaveSum *= Smoothness;\r\n  OctaveSum += (1 - Smoothness) * FlatLevel;\r\n\r\n  let OtherMountainLevel = (_Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 15000, Z / 15000, 1236) / 2 + 0.5) * 1200;\r\n  OtherMountainLevel *= Smoothness;\r\n\r\n  const MountainWeight = MountainWeighting(OctaveSum);\r\n  const OtherWeight = OtherMountainWeighting(OtherMountainLevel + OctaveSum);\r\n\r\n  let Result = OctaveSum;\r\n  Result += Mountain * MountainWeight * 200;\r\n  Result += OtherMountain * OtherWeight * 800;\r\n  Result += Weighting150(OctaveSum) * (1 - Mountain * MountainWeight) ** 1 * 40;\r\n  Result -= Things(_Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 1200, Z / 1200, 1100)) * OtherMountain * OtherWeight * 10;\r\n  Result += Weighting100(OctaveSum) * (Mountain * MountainWeight) ** 0.7 * 70;\r\n\r\n  Result *= 1 - SmoothShoreWeighting(Result);\r\n  Result /= .5;\r\n\r\n  return Result;// + Math.floor((X + Z) / 100.) * 64.;\r\n};\r\n\r\nfunction GetHeight(X, Z){\r\n  //return 0;//(((X & 7) === 3 || (X & 7) === 4) && ((Z & 7) === 3 || (Z & 7) === 4)) ? 192. : 0.;\r\n  //return 10;\r\n  /* //Basic volcano\r\n  const Worley = WorleyNoise.Euclidean(X / 1000., Z / 1000., 0.);\r\n  return MountainWeighting(Worley[0] * 41100.) * 200.;\r\n   */\r\n\r\n\r\n  //Looks like a nice texture for mountains\r\n  /*let OctaveSum = 0;\r\n  for(let i = 1; i < 9; i++){\r\n    OctaveSum += Simplex.simplex3(X / 2 ** (i + 3), Z / 2 ** (i + 3), 1536) * 2 ** i;\r\n  }\r\n\r\n  const Worley = WorleyNoise.Euclidean((X + OctaveSum / 2.) / 100., (Z + OctaveSum / 2.) / 100., 0.);\r\n  return Math.pow(Worley[0], .3) * 200.;*/\r\n\r\n  /* //Could be another good base for mountains\r\n  let OctaveSum = 0;\r\n  for(let i = 1; i < 9; i++){\r\n    OctaveSum += Simplex.simplex3(X / 2 ** (i + 3), Z / 2 ** (i + 3), 1536) * 2 ** i;\r\n  }\r\n\r\n  const Worley = WorleyNoise.Euclidean((X + OctaveSum) / 100., (Z + OctaveSum) / 100., 0.);\r\n  return MountainWeighting(Math.pow(Worley[0], .3) * 200. + 100.) * 200.;\r\n\r\n   */\r\n\r\n  /* //Very good mountain map\r\n  let OctaveSum = 0;\r\n  for(let i = 1; i < 9; i++){\r\n    OctaveSum += Simplex.simplex3(X / 2 ** (i + 3), Z / 2 ** (i + 3), 1536) * 2 ** i;\r\n  }\r\n\r\n  return Weighting1(OctaveSum / 512.) * 200.;\r\n\r\n   */\r\n  //return WeightTowardsAsymmetric(300., 100.)(X) * 200.;\r\n\r\n  //return WorleyNoise.FasterNoise(X / 130., Z / 130.) * 200.;\r\n\r\n  const Octaves = new Float32Array(18);\r\n  for(let i = 0; i < 18; i++){\r\n    Octaves[i] = _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 2 ** i, Z / 2 ** i, 1536);\r\n  }\r\n\r\n  let OctaveSum10_17 = 0.;\r\n  for(let i = 0, Min = 10, Max = 17, Count = Max - Min; i < Count; ++i) OctaveSum10_17 += Octaves[i + Min] / (2 ** (Count - i));\r\n\r\n  let OctaveSum1_5 = 0.;\r\n  for(let i = 0, Min = 1, Max = 5, Count = Max - Min; i < Count; ++i) OctaveSum1_5 += Octaves[i + Min] / (2 ** (Count - i));\r\n\r\n  let OctaveSum3_9 = 0.;\r\n  for(let i = 0, Min = 3, Max = 9, Count = Max - Min; i < Count; ++i) OctaveSum3_9 += Octaves[i + Min] / (2 ** (Count - i));\r\n\r\n\r\n\r\n  //const Worley1 = WorleyNoise.Euclidean(X / 300. + OctaveSum1_5 / 45., Z / 300. + OctaveSum1_5 / 45., 0.);\r\n\r\n  const DistributionNoise = _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 32768, Z / 32768, 1542);\r\n\r\n  const CliffNoise1 = _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 512., Z / 512., 1539) * .75 * OctaveSum1_5 * .25;\r\n  const CliffNoise2 = _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 256., Z / 256., 1539.4);\r\n\r\n  const Worley1 = WorleyNoise.FasterNoise(X / 40000., Z / 40000.);\r\n  const Worley2 = WorleyNoise.FasterNoise(X / 2000., Z / 2000., 0.);// + WorleyNoise.FasterNoise(X / 3000., Z / 3000.);\r\n\r\n  const Other1 = _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 16384., Z / 16384., 1555);\r\n  const Other2 = _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 4096., Z / 4096., 1555);\r\n  const Other3 = _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].simplex3(X / 16384., Z / 16384., 1555.5);\r\n\r\n\r\n  let MountainRegionWeighting = BiasedSerpentineWeightingFunction(WeightTowards(.47 + .10 * Other3, .10 + .06 * (Other1 * .8 + Other2 * .2), .57)(OctaveSum10_17));//BetterSerpentineWeightingFunction(Worley1, 1.);\r\n  let MountainWeighting = MountainRegionWeighting;//MountainRegionWeighting * WeightTowards(.47 + .10 * Other3, .10 + .06 * (Other1 * .8 + Other2 * .2), .57)(OctaveSum6_15);\r\n  MountainWeighting *= Worley2;\r\n  MountainWeighting += MountainRegionWeighting * .5;\r\n\r\n  let MountainMap = MountainWeighting;//WeightTowards(.47 + .10 * Other3, .10 + .06 * (Other1 * .8 + Other2 * .2), .57)(OctaveSum6_15);\r\n\r\n  //MountainMap += WeightTowardsAsymmetric(.15, .0094)(MountainMap) * .0106 * Math.max(0., Octaves[8] * 2. - 1.);\r\n  //MountainMap += WeightTowardsAsymmetric(.43, .0094)(1. - OctaveSum6_15) * .0106 * Math.min(1., Math.max(0., 2. - MountainMap * 5.));// * Math.max(0., Octaves[9] * 2. - 1.);\r\n  //MountainMap += WeightTowardsAsymmetric(.38, .0094)(1. - OctaveSum6_15) * .0106 * Math.min(1., Math.max(0., 3.3 - MountainMap * 7.)) * (CliffNoise2 + 1.) / 2.;\r\n  //MountainMap += WeightTowardsAsymmetric(.33, .0096)(1. - OctaveSum6_15) * CliffNoise1 * .0106;\r\n  //MountainMap += Cliffs1(MountainMap) * .039 * OctaveSum3_9 * Math.max(0., Math.min(1.6 - 2. * MountainMap));\r\n\r\n  //MountainMap += Cliffs2(MountainMap) * .00014 + .00007 * OctaveSum3_9;\r\n  //MountainMap += .001 * OctaveSum1_5 * Worley2;\r\n  // /tp -5212 463 -222000\r\n\r\n  return MountainMap * 2200.;\r\n\r\n  //const Worley = WorleyNoise.Euclidean(X / 100., Z / 100., 0.);\r\n  //return Worley[0] * 200.;\r\n\r\n/*\r\n\r\n  //return X / 140.;//0.;//(X + Z) / 6. + 64.;//128.;//254. + //\r\n  X *= .5;\r\n  Z *= .5;\r\n\r\n  let Smoothness = GetSerpentineWeightingAt(1.4, Simplex.simplex3(X / 10000, Z / 10000, 1536) / 2 + 0.5);\r\n  let FlatLevel = (Simplex.simplex3(X / 30000, Z / 30000, 1536) / 2 + 0.5) * 200;\r\n\r\n  let OctaveSum = 0;\r\n  for(let i = 1; i < 9; i++){\r\n    OctaveSum += Simplex.simplex3(X / 2 ** (1.08 * i + 3), Z / 2 ** (1.08 * i + 3), 1536) * 2 ** i;\r\n  }\r\n\r\n  let Mountain = (1 - Math.abs( (Math.sin(Math.PI * (Simplex.simplex3(X / 2500, Z / 2500, 1100) - 0.5)) / 2 + 0.5) ** 0.5 ));\r\n\r\n  let OtherMountain = (1 - Math.abs( (Math.sin(Math.PI * (Simplex.simplex3(X / 12500, Z / 12500, 1100) - 0.5)) / 2 + 0.5) ** 0.5 ));\r\n  OtherMountain *= 0.7 * OneWeighting(OtherMountain) + 0.3 * OneSmallerWeighting(OtherMountain);\r\n\r\n  OctaveSum *= Smoothness;\r\n  OctaveSum += (1 - Smoothness) * FlatLevel;\r\n\r\n  let OtherMountainLevel = (Simplex.simplex3(X / 15000, Z / 15000, 1236) / 2 + 0.5) * 1200;\r\n  OtherMountainLevel *= Smoothness;\r\n\r\n  const MountainWeight = MountainWeighting(OctaveSum);\r\n  const OtherWeight = OtherMountainWeighting(OtherMountainLevel + OctaveSum);\r\n\r\n  let Result = OctaveSum;\r\n  Result += Mountain * MountainWeight * 200;\r\n  Result += OtherMountain * OtherWeight * 800;\r\n  Result += Weighting150(OctaveSum) * (1 - Mountain * MountainWeight) ** 1 * 40;\r\n  Result -= Things(Simplex.simplex3(X / 1200, Z / 1200, 1100)) * OtherMountain * OtherWeight * 10;\r\n  Result += Weighting100(OctaveSum) * (Mountain * MountainWeight) ** 0.7 * 70;\r\n\r\n  Result *= 1 - SmoothShoreWeighting(Result);\r\n  Result /= .5;\r\n\r\n  return Result;// + Math.floor((X + Z) / 100.) * 64.;\r\n\r\n */\r\n};\r\n\r\nfunction ReSeed(NewSeed){\r\n  _Simplex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seed(NewSeed);\r\n  WorleyNoise.setSeed(NewSeed);\r\n};\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/GetHeight.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/Region.mjs":
/*!**************************************!*\
  !*** ./VoxelEngine/World/Region.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Region\": () => (/* binding */ Region),\n/* harmony export */   \"VirtualRegion\": () => (/* binding */ VirtualRegion)\n/* harmony export */ });\n/* harmony import */ var _RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegionSD.mjs */ \"./VoxelEngine/World/RegionSD.mjs\");\n\r\nclass Region{\r\n  static Version = \"Alpha 0.1.4.16\";\r\n  static Build = 33;\r\n\r\n  static X_LENGTH = 32;\r\n  static X_POWER = 5;\r\n  static X_LENGTH_SQUARED = 1024;\r\n  static X_LENGTH_MINUS_ONE = 31;\r\n\r\n  static Y_LENGTH = 64;\r\n  static Y_POWER = 6;\r\n  static Y_LENGTH_SQUARED = 4096;\r\n  static Y_LENGTH_MINUS_ONE = 63;\r\n\r\n  static Z_LENGTH = 32;\r\n  static Z_POWER = 5;\r\n  static Z_LENGTH_SQUARED = 1024;\r\n  static Z_LENGTH_MINUS_ONE = 31;\r\n\r\n  constructor(SharedData, RegionData, RegionX, RegionY, RegionZ){\r\n    this.SharedData = SharedData;\r\n    this.RegionData = RegionData;\r\n\r\n    this.RegionX = RegionX;\r\n    this.RegionY = RegionY;\r\n    this.RegionZ = RegionZ;\r\n\r\n    this.ThreadSafeTime = self.performance.now();\r\n\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REQUEST_TIME] = this.ThreadSafeTime;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UNLOAD_TIME] = -Infinity;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REGION_X] = RegionX;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REGION_Y] = RegionY;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REGION_Z] = RegionZ;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DEPTH] = -1;\r\n  }\r\n\r\n  GetIdentifier(){\r\n    return this.RegionX + \",\" + this.RegionY + \",\" + this.RegionZ;\r\n  }\r\n\r\n  Init(RegionData, CommonBlock, IsEntirelySolid){\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOADED] = 1;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK] = CommonBlock ?? -1;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IS_ENTIRELY_SOLID] = IsEntirelySolid | 0;\r\n\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_REQUIRED] = 1;\r\n\r\n    if(!CommonBlock || this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DEPTH] !== -1){\r\n      this.RegionData = RegionData;\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 1;\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REVERSE_DATA_ACKNOWLEDGED] = 1;\r\n      return true;\r\n    } else{\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 0;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  Destruct(){\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UNLOAD_TIME] = self.performance.now();\r\n\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOADED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_REQUIRED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_UPDATE_REQUIRED] = 0;\r\n\r\n    this.RegionData = undefined;\r\n  }\r\n\r\n  SetBlock(rX, rY, rZ, BlockID){\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_REQUIRED] = 1;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_UPDATE_REQUIRED] = 1;\r\n\r\n    if(this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IS_ENTIRELY_SOLID] === 1 && BlockID === 0){\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IS_ENTIRELY_SOLID] = 0;\r\n    }\r\n\r\n    let NewlyCreatedData = false;\r\n    if(!this.RegionData){\r\n      this.RegionData = new Uint16Array(new SharedArrayBuffer(Region.X_LENGTH * Region.Y_LENGTH * Region.Z_LENGTH * 2));\r\n      NewlyCreatedData = true;\r\n    }\r\n\r\n    if(this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK] !== -1){\r\n      if(NewlyCreatedData) this.RegionData.set(this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK]);\r\n\r\n      if(BlockID !== this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK]) this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK] = -1;\r\n    }\r\n    this.Data[rX * Region.Z_LENGTH * Region.Y_LENGTH + rY * Region.Z_LENGTH + rZ] = BlockID;\r\n    return NewlyCreatedData;\r\n  }\r\n}\r\n\r\nclass VirtualRegion extends Region{\r\n  constructor(SharedData, RegionData, RegionX, RegionY, RegionZ, Depth){\r\n    SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DEPTH] = Depth;\r\n    super(SharedData, RegionData, RegionX, RegionY, RegionZ);\r\n    this.Depth = Depth;\r\n  }\r\n}\r\n/*\r\nexport class MicroRegion extends Region{\r\n\r\n  static X_LENGTH = 16;\r\n  static X_POWER = 4;\r\n  static X_LENGTH_SQUARED = 256;\r\n  static X_LENGTH_MINUS_ONE = 15;\r\n\r\n  static Y_LENGTH = 16;\r\n  static Y_POWER = 4;\r\n  static Y_LENGTH_SQUARED = 256;\r\n  static Y_LENGTH_MINUS_ONE = 15;\r\n\r\n  static Z_LENGTH = 16;\r\n  static Z_POWER = 4;\r\n  static Z_LENGTH_SQUARED = 256;\r\n  static Z_LENGTH_MINUS_ONE = 15;\r\n\r\n  constructor(RegionX, RegionY, RegionZ){\r\n    super(RegionX, RegionY, RegionZ);\r\n  }\r\n}*/\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/Region.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/RegionSD.mjs":
/*!****************************************!*\
  !*** ./VoxelEngine/World/RegionSD.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst REGION_SD = {\r\n  \"REQUEST_TIME\": 0,\r\n\r\n  \"UNLOAD_TIME\": 1,\r\n  \"DATA_ATTACHED\": 2,\r\n\r\n  \"MAIN_THREAD_RECEIVED\": 3,\r\n  \"LOADED\": 4,\r\n  \"LOAD_ACKNOWLEDGED\": 5,\r\n  \"GD_REQUIRED\": 6,\r\n  \"GD_UPDATE_REQUIRED\": 7,\r\n  \"REVERSE_DATA_ACKNOWLEDGED\": 8,\r\n\r\n  \"REGION_X\": 9,\r\n  \"REGION_Y\": 10,\r\n  \"REGION_Z\": 11,\r\n  \"DEPTH\": 12,\r\n\r\n  \"IS_ENTIRELY_SOLID\": 13,\r\n  \"COMMON_BLOCK\": 14,\r\n\r\n  \"LOADING_STAGE\": 15,\r\n\r\n  \"BUFFER_SIZE\": 16 * 8\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (REGION_SD);\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/RegionSD.mjs?");

/***/ })

}]);