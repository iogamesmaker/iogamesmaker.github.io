"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkElectronProject"] = self["webpackChunkElectronProject"] || []).push([["VoxelEngine_Libraries_SVM_SVMUtils_mjs"],{

/***/ "./VoxelEngine/Libraries/BitSetter/BitSetter.mjs":
/*!*******************************************************!*\
  !*** ./VoxelEngine/Libraries/BitSetter/BitSetter.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GetUint\": () => (/* binding */ GetUint),\n/* harmony export */   \"SetUint\": () => (/* binding */ SetUint)\n/* harmony export */ });\nfunction SetUint(View, ReadOffset, BitSize){ //Wont work for >Uint24.\r\n  return function(Position, Value){\r\n    Value &= (1 << BitSize) - 1;\r\n    const Index32 = ReadOffset + Math.floor(Position * BitSize / 8);\r\n    const Index32Offset = (Position * BitSize) & 7;\r\n    let Uint32 = View.getUint32(Index32, true);\r\n\r\n    Uint32 &= ~(((1 << BitSize) - 1) << Index32Offset); //Clear bits\r\n    Uint32 |= Value << Index32Offset; //Set bits\r\n\r\n    View.setUint32(Index32, Uint32, true);\r\n  };\r\n};\r\n\r\n\r\nfunction GetUint(View, ReadOffset, BitSize){ //Wont work for >Uint24.\r\n  return function(Position){\r\n    const Index32 = ReadOffset + Math.floor(Position * BitSize / 8);\r\n    const Index32Offset = (Position * BitSize) & 7;\r\n    return (View.getUint32(Index32, true) >> Index32Offset) & ((1 << BitSize) - 1);\r\n  };\r\n};\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Libraries/BitSetter/BitSetter.mjs?");

/***/ }),

/***/ "./VoxelEngine/Libraries/SVM/SVMUtils.mjs":
/*!************************************************!*\
  !*** ./VoxelEngine/Libraries/SVM/SVMUtils.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SVMUtils)\n/* harmony export */ });\n/* harmony import */ var _SVM_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVM.mjs */ \"./VoxelEngine/Libraries/SVM/SVM.mjs\");\n/* harmony import */ var _ScalesContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ScalesContainer.mjs */ \"./VoxelEngine/Libraries/SVM/ScalesContainer.mjs\");\n/* harmony import */ var _Libraries_Utilities_0_7_13_8_Utilities_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Libraries/Utilities/0.7.13.8/Utilities.mjs */ \"./VoxelEngine/Libraries/Utilities/0.7.13.8/Utilities.mjs\");\n/* harmony import */ var _BitSetter_BitSetter_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../BitSetter/BitSetter.mjs */ \"./VoxelEngine/Libraries/BitSetter/BitSetter.mjs\");\n/* harmony import */ var _Block_DefaultForeignMapping_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Block/DefaultForeignMapping.json */ \"./VoxelEngine/Block/DefaultForeignMapping.json\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst SIZE_HEADER = 3;\r\nconst SIZE_VERSION = 2;\r\nconst SIZE_OID_HEADER = 1;\r\nconst SIZE_CID_HEADER = 1;\r\nconst SIZE_INTERPOLATION = 1;\r\nconst SIZE_SIZE_INDICATOR = 4;\r\nconst SIZE_SCALE_NUMBER = 4;\r\nconst SIZE_SCALE_LOCATION = 4;\r\n\r\nconst SIZE_COORDINATE = 4;\r\n\r\n//Everything will be in big endian because it will be easier to address\r\nclass SVMUtils{\r\n  static VERSION = 1;\r\n  static DefaultSVMOptions = {\r\n    \"BitsPerOID\": 16,\r\n    \"BitsPerCID\": -1,\r\n    \"ScaleInterpolationMethod\": _SVM_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].INTERPOLATION_NEAREST_NEIGHBOUR\r\n  };\r\n  static CreateSVM(Options, Scales){\r\n    Options = _Libraries_Utilities_0_7_13_8_Utilities_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].MergeObjects(Options, SVMUtils.DefaultSVMOptions);\r\n    const BitsPerOID = Options.BitsPerOID;\r\n    const BytesPerOID = Math.ceil(BitsPerOID / 8);\r\n\r\n    let BufferSize = 0;\r\n    const IDMapping = new Map;\r\n    let CompressedIDs = 0;\r\n    for(const Scale of Scales){\r\n      const Data = Scale.Data;\r\n      for(let i = 0, Length = Data.length; i < Length; i++){\r\n        if(!IDMapping.has(Data[i])) IDMapping.set(Data[i], CompressedIDs++);\r\n      }\r\n    }\r\n    const BitsPerCID = Math.ceil(Math.log2(CompressedIDs + 1));\r\n\r\n    BufferSize += SIZE_HEADER\r\n                + SIZE_VERSION\r\n                + SIZE_OID_HEADER\r\n                + SIZE_CID_HEADER\r\n                + SIZE_SIZE_INDICATOR\r\n                + BytesPerOID * 2 * CompressedIDs\r\n                + SIZE_SIZE_INDICATOR\r\n                + Scales.length * (SIZE_SCALE_NUMBER + SIZE_SCALE_LOCATION)\r\n                + SIZE_SIZE_INDICATOR\r\n                + (Options.Metadata?.byteLength ?? 0)\r\n                + SIZE_INTERPOLATION\r\n                + Scales.length * 6 * SIZE_COORDINATE\r\n                + 4; //This +4 is to make reading data easier. Don't worry about it.\r\n\r\n    for(const Scale of Scales){\r\n      BufferSize += Math.ceil(Scale.Data.length * BitsPerCID / 8);\r\n    }\r\n\r\n    const Buffer = new ArrayBuffer(BufferSize);\r\n    const View = new DataView(Buffer);\r\n\r\n    let ByteOffset = 0;\r\n\r\n    for(const Char of \"svm\") View.setUint8(ByteOffset++, Char.charCodeAt(0));\r\n\r\n    View.setUint16(ByteOffset, SVMUtils.VERSION);\r\n    ByteOffset += 2;\r\n\r\n    View.setUint8(ByteOffset++, BitsPerOID);\r\n    View.setUint8(ByteOffset++, BitsPerCID);\r\n\r\n    View.setUint32(ByteOffset, BytesPerOID * 2 * CompressedIDs);\r\n    ByteOffset += 4;\r\n\r\n    {\r\n      let Setter;\r\n      let Increment;\r\n      if(BytesPerOID === 1) Setter = View.setUint8.bind(View), Increment = 1;\r\n      else if(BytesPerOID === 2) Setter = View.setUint16.bind(View), Increment = 2;\r\n      else Setter = View.setUint32.bind(View), Increment = 4;\r\n      for(const [OriginalID, CompressedID] of IDMapping){\r\n        Setter(ByteOffset, OriginalID);\r\n        ByteOffset += Increment;\r\n        Setter(ByteOffset, CompressedID);\r\n        ByteOffset += Increment;\r\n      }\r\n    }\r\n\r\n    View.setUint8(ByteOffset++, Options.ScaleInterpolationMethod);\r\n\r\n    View.setUint32(ByteOffset, Scales.length * (4 + 4));\r\n    ByteOffset += 4;\r\n\r\n    const ScaleByteOffsetOffsets = {};\r\n    for(const Scale of Scales){\r\n      View.setFloat32(ByteOffset, Scale.Scale);\r\n      ByteOffset += 4;\r\n      ScaleByteOffsetOffsets[Scale.Scale] = ByteOffset;\r\n      ByteOffset += 4;\r\n    }\r\n\r\n    View.setUint32(ByteOffset, Options.Metadata?.byteLength ?? 0);\r\n    ByteOffset += 4;\r\n\r\n    if(Options.Metadata){\r\n      const MetadataArray = new Uint8Array(Options.Metadata); //Could've also made a DataView but this might be faster.\r\n      //Not sure how safe TypedArray.set would be here due to possible endianness issues...\r\n      for(let i = 0, Length = MetadataArray.length; i < Length; i++){\r\n        View.setUint8(ByteOffset++, MetadataArray[i]);\r\n      }\r\n    }\r\n\r\n    for(const Scale of Scales){\r\n      View.setUint32(ScaleByteOffsetOffsets[Scale.Scale], ByteOffset);\r\n\r\n      View.setUint32(ByteOffset, Scale.XLength);\r\n      ByteOffset += 4;\r\n      View.setUint32(ByteOffset, Scale.YLength);\r\n      ByteOffset += 4;\r\n      View.setUint32(ByteOffset, Scale.ZLength);\r\n      ByteOffset += 4;\r\n      View.setUint32(ByteOffset, Scale.XOffset);\r\n      ByteOffset += 4;\r\n      View.setUint32(ByteOffset, Scale.YOffset);\r\n      ByteOffset += 4;\r\n      View.setUint32(ByteOffset, Scale.ZOffset);\r\n      ByteOffset += 4;\r\n\r\n      const CompressedSetter = (0,_BitSetter_BitSetter_mjs__WEBPACK_IMPORTED_MODULE_3__.SetUint)(View, ByteOffset, BitsPerCID);\r\n      const Data = Scale.Data;\r\n\r\n      for(let i = 0, Length = Data.length; i < Length; i++){\r\n        CompressedSetter(i, IDMapping.get(Data[i]));\r\n      }\r\n\r\n      ByteOffset += Math.ceil(Data.length * BitsPerCID / 8);\r\n    }\r\n\r\n    return Buffer;\r\n  }\r\n\r\n  static DeserialiseSVM(SVM){\r\n    let View = new DataView(SVM);\r\n    let ByteOffset = 0;\r\n\r\n    let ValidHeader = true;\r\n    if(\r\n      String.fromCharCode(View.getUint8(0)) !== \"s\" ||\r\n      String.fromCharCode(View.getUint8(1)) !== \"v\" ||\r\n      String.fromCharCode(View.getUint8(2)) !== \"m\"){\r\n\r\n      console.warn(\"Invalid header. This probably isn't an svm.\");\r\n      ValidHeader = false;\r\n    }\r\n    ByteOffset += 3;\r\n\r\n    const Version = View.getUint16(ByteOffset);\r\n    ByteOffset += 2;\r\n\r\n    const BitsPerOID = View.getUint8(ByteOffset++);\r\n    const BytesPerOID = Math.ceil(BitsPerOID / 8);\r\n    const BitsPerCID = View.getUint8(ByteOffset++);\r\n    const BytesPerCID = Math.ceil(BitsPerCID / 8);\r\n\r\n    const ReverseIDMapping = new Map;\r\n\r\n    {\r\n      const IDMappingSize = View.getUint32(ByteOffset);\r\n      ByteOffset += 4;\r\n\r\n      let Getter;\r\n      let Increment;\r\n      if(BytesPerOID === 1) Getter = View.getUint8.bind(View), Increment = 1;\r\n      else if(BytesPerOID === 2) Getter = View.getUint16.bind(View), Increment = 2;\r\n      else Getter = View.getUint32.bind(View), Increment = 4;\r\n\r\n      const FinalOffset = ByteOffset + IDMappingSize;\r\n      while(ByteOffset < FinalOffset){\r\n        ReverseIDMapping.set(Getter(ByteOffset + Increment), Getter(ByteOffset));\r\n        ByteOffset += Increment * 2;\r\n      }\r\n    }\r\n\r\n    const InterpolationMethod = View.getUint8(ByteOffset++);\r\n\r\n    const ScaleIndex = new Map;\r\n\r\n    {\r\n      const ScaleIndexSize = View.getUint32(ByteOffset);\r\n      ByteOffset += 4;\r\n\r\n      const FinalOffset = ScaleIndexSize + ByteOffset;\r\n      while(ByteOffset < FinalOffset){\r\n        ScaleIndex.set(View.getFloat32(ByteOffset), View.getUint32(ByteOffset + 4));\r\n        ByteOffset += 8;\r\n      }\r\n    }\r\n\r\n    const MetadataSize = View.getUint32(ByteOffset);\r\n    ByteOffset += 4;\r\n\r\n    const Metadata = new ArrayBuffer(MetadataSize);\r\n\r\n    {\r\n      const MetadataArray = new Uint8Array(Metadata);\r\n\r\n      for(let i = 0, Length = MetadataArray.length; i < Length; i++){\r\n        MetadataArray[i] = View.getUint8(ByteOffset++);\r\n      }\r\n    }\r\n\r\n\r\n    const Scales = {};\r\n\r\n    for(const [ScaleValue, Offset] of ScaleIndex){\r\n      Scales[ScaleValue] = {};\r\n      const ScaleObject = Scales[ScaleValue];\r\n      ScaleObject.Scale = ScaleValue;\r\n\r\n      ScaleObject.XLength = View.getUint32(Offset + 0);\r\n      ScaleObject.YLength = View.getUint32(Offset + 4);\r\n      ScaleObject.ZLength = View.getUint32(Offset + 8);\r\n      ScaleObject.XOffset = View.getUint32(Offset + 12);\r\n      ScaleObject.YOffset = View.getUint32(Offset + 16);\r\n      ScaleObject.ZOffset = View.getUint32(Offset + 20);\r\n\r\n      const CompressedGetter = (0,_BitSetter_BitSetter_mjs__WEBPACK_IMPORTED_MODULE_3__.GetUint)(View, Offset + 24, BitsPerCID);\r\n\r\n      let Data;\r\n\r\n      const Size = ScaleObject.XLength * ScaleObject.YLength * ScaleObject.ZLength;\r\n\r\n      if(BytesPerOID === 1) Data = new Uint8Array(Size);\r\n      else if(BytesPerOID === 2) Data = new Uint16Array(Size);\r\n      else Data = new Uint32Array(Size);\r\n\r\n      //I am creating typed arrays instead of DataViews because I want to convert the data to the system's endianness.\r\n\r\n      for(let i = 0, Length = Data.length; i < Length; i++){\r\n        Data[i] = ReverseIDMapping.get(CompressedGetter(i));\r\n      }\r\n\r\n      ScaleObject.Data = Data;\r\n    }\r\n\r\n    return new SVM(new _ScalesContainer_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](Scales, InterpolationMethod), Metadata, {\r\n      \"Version\": Version,\r\n      \"ValidHeader\": ValidHeader\r\n    });\r\n  }\r\n\r\n  static DeserialiseBOP(BOPFile, Mapping, Offset){\r\n    if(!Mapping){\r\n      Mapping = {\r\n        \"biomesoplenty:leaves_4:2\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:leaves\").ID,\r\n        \"biomesoplenty:log_2\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:wood\").ID,\r\n        \"biomesoplenty:log_2:8\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:wood\").ID,\r\n        \"minecraft:spruce_log\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:wood\").ID,\r\n        \"minecraft:spruce_leaves\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:leaves\").ID,\r\n        \"minecraft:oak_log\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:oak_wood\").ID,\r\n        \"minecraft:oak_leaves\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:oak_leaves\").ID,\r\n        \"NotFound\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"primary:error\").ID,\r\n        \"LOG\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:oak_wood\").ID,\r\n        \"LEAVES\": Application.Main.BlockRegistry.GetBlockByIdentifier(\"default:oak_leaves\").ID\r\n      };\r\n    }\r\n    let Lines = BOPFile.split(\"\\u000a\");\r\n\r\n    const MappedBlocks = new Map;\r\n\r\n    const XOffset = Offset.X;\r\n    const YOffset = Offset.Y;\r\n    const ZOffset = Offset.Z;\r\n\r\n    let MinX = Infinity, MinY = Infinity, MinZ = Infinity;\r\n    let MaxX = -Infinity, MaxY = -Infinity, MaxZ = -Infinity;\r\n\r\n    for(let i = 0; i < Lines.length; i++){\r\n      if(!(Lines[i].includes(\"(\") && (Lines[i].split(\"(\")[0] === \"Block\" || Lines[i].split(\"(\")[0] === \"B\"))) continue;\r\n      let Params = Lines[i].split(\"(\")[1].split(\")\")[0].split(/\\,\\s?(?![^\\[]*\\])/);\r\n\r\n      const RelativeX = Number.parseInt(Params[0]) + XOffset;\r\n      const RelativeY = Number.parseInt(Params[1]) + YOffset;\r\n      const RelativeZ = Number.parseInt(Params[2]) + ZOffset;\r\n      const ForeignType = Params[3].replace(/ *\\[[^)]*\\] */g, \"\");\r\n\r\n      MappedBlocks.set(RelativeX + \", \" + RelativeY + \", \" + RelativeZ, {\r\n        \"RelativeX\": RelativeX,\r\n        \"RelativeY\": RelativeY,\r\n        \"RelativeZ\": RelativeZ,\r\n        \"ForeignType\": ForeignType\r\n      });\r\n\r\n      if(MinX > RelativeX) MinX = RelativeX;\r\n      if(MaxX < RelativeX) MaxX = RelativeX;\r\n      if(MinY > RelativeY) MinY = RelativeY;\r\n      if(MaxY < RelativeY) MaxY = RelativeY;\r\n      if(MinZ > RelativeZ) MinZ = RelativeZ;\r\n      if(MaxZ < RelativeZ) MaxZ = RelativeZ;\r\n    }\r\n\r\n    const XLength = MaxX - MinX + 1;\r\n    const YLength = MaxY - MinY + 1;\r\n    const ZLength = MaxZ - MinZ + 1;\r\n\r\n    const DataArray = new Uint16Array(XLength * YLength * ZLength);\r\n\r\n    for(const [Identifier, Block] of MappedBlocks){\r\n      const X = Block.RelativeX - MinX;\r\n      const Y = Block.RelativeY - MinY;\r\n      const Z = Block.RelativeZ - MinZ;\r\n      const Index = X * YLength * ZLength + Y * ZLength + Z;\r\n      DataArray[Index] = Mapping[Block.ForeignType] ?? Mapping[\"NotFound\"];\r\n    }\r\n\r\n    return new _SVM_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new _ScalesContainer_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\r\n      1: {\r\n        \"XOffset\": MinX,\r\n        \"YOffset\": MinY,\r\n        \"ZOffset\": MinZ,\r\n        \"XLength\": XLength,\r\n        \"YLength\": YLength,\r\n        \"ZLength\": ZLength,\r\n        \"Data\": DataArray\r\n      }\r\n    }), null, {\"FromBOP\": true}); //Nearest neighbour interpolation method\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Libraries/SVM/SVMUtils.mjs?");

/***/ }),

/***/ "./VoxelEngine/Block/DefaultForeignMapping.json":
/*!******************************************************!*\
  !*** ./VoxelEngine/Block/DefaultForeignMapping.json ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = {};\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Block/DefaultForeignMapping.json?");

/***/ })

}]);