/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./VoxelEngine/BackgroundTasks/SharedDebugData.mjs":
/*!*********************************************************!*\
  !*** ./VoxelEngine/BackgroundTasks/SharedDebugData.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FREE_GPU_SEGMENTS\": () => (/* binding */ FREE_GPU_SEGMENTS),\n/* harmony export */   \"MAX_GPU_SEGMENTS\": () => (/* binding */ MAX_GPU_SEGMENTS)\n/* harmony export */ });\nconst FREE_GPU_SEGMENTS = 0;\r\nconst MAX_GPU_SEGMENTS = 1;\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/BackgroundTasks/SharedDebugData.mjs?");

/***/ }),

/***/ "./VoxelEngine/BackgroundTasks/WorkerLoadingPipeline.mjs":
/*!***************************************************************!*\
  !*** ./VoxelEngine/BackgroundTasks/WorkerLoadingPipeline.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Block_BlockRegistry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Block/BlockRegistry.mjs */ \"./VoxelEngine/Block/BlockRegistry.mjs\");\n/* harmony import */ var _World_LoadManager_LoadManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../World/LoadManager/LoadManager.mjs */ \"./VoxelEngine/World/LoadManager/LoadManager.mjs\");\n\r\n\r\n\r\nif(false) {}\r\n\r\nself.EventHandler = {};\r\nself.MainLoadManager = null;\r\n\r\nself.Settings = {\r\n  \"VirtualRegionDepths\": 7,\r\n  \"LoadDistance\": 4\r\n};\r\n\r\nself.onmessage = function(Event){\r\n  EventHandler[Event.data.Request]?.(Event.data);\r\n};\r\n\r\nEventHandler.SaveStuff = function(Data){\r\n  self.MainLoadManager = new _World_LoadManager_LoadManager_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](Data);\r\n};\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/BackgroundTasks/WorkerLoadingPipeline.mjs?");

/***/ }),

/***/ "./VoxelEngine/Block/Block.mjs":
/*!*************************************!*\
  !*** ./VoxelEngine/Block/Block.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Block)\n/* harmony export */ });\nclass Block{\r\n  constructor(Identifier, Properties, ID = -1){ //The Identifier is a string like \"default:air\", not its ID which would be 0.\r\n    this.Identifier = Identifier;\r\n    this.Properties = Properties;\r\n    this.ID = ID;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Block/Block.mjs?");

/***/ }),

/***/ "./VoxelEngine/Block/BlockRegistry.mjs":
/*!*********************************************!*\
  !*** ./VoxelEngine/Block/BlockRegistry.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BlockRegistry)\n/* harmony export */ });\n/* harmony import */ var _Block_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Block.mjs */ \"./VoxelEngine/Block/Block.mjs\");\n\r\nclass BlockRegistry{\r\n  static MAX_BLOCK_IDS = 65536;\r\n  constructor(){\r\n    this.BlockIDMapping = {};\r\n    this.BlockIdentifierMapping = {};\r\n    this.RegisterPrimaryIDs();\r\n  }\r\n  static Initialise(BlockIDMapping, BlockIdentifierMapping){\r\n    let This = Object.create(this.prototype);\r\n    This.BlockIDMapping = BlockIDMapping;\r\n    This.BlockIdentifierMapping = BlockIdentifierMapping;\r\n    return This;\r\n  }\r\n  RegisterPrimaryIDs(){\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"primary:air\", {\"Solid\": false, \"Invisible\": true, \"Transparent\": true, \"Precedence\": -32}, 0), 0);\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"primary:not_loaded\", {\"Solid\": true, \"Invisible\": true, \"Transparent\": true}, 49148), 49148);\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"primary:placeholder\", {\"Solid\": true, \"Invisible\": false, \"Transparent\": false}, 49149), 49149);\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"primary:temp\", {\"Solid\": true, \"Invisible\": false, \"Transparent\": false}, 49150), 49150);\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"primary:error\", {\"Solid\": true, \"Invisible\": false, \"Transparent\": false, \"Precedence\": Infinity}, 49151), 49151);\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"primary:custom\", {\"Solid\": true, \"Invisible\": false, \"Transparent\": false, \"Precedence\": 1024}, 65535), 65535);\r\n\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"generic:solid\", {\"Solid\": true, \"Invisible\": false, \"Transparent\": false}, 61440), 61440);\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"generic:gas\", {\"Solid\": false, \"Invisible\": true, \"Transparent\": true}, 61441), 61441);\r\n    this.RegisterBlock(new _Block_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"generic:fluid\", {\"Solid\": false, \"Invisible\": false, \"Transparent\": true}, 61442), 61442);\r\n  }\r\n  RegisterBlock(Block, ID){\r\n    if(ID !== undefined){\r\n      if(ID < 0 || ID >= BlockRegistry.MAX_BLOCK_IDS) throw new Error(\"Invalid Block ID.\");\r\n      if(this.BlockIDMapping[ID] !== undefined) throw new Error(\"The Block ID \" + ID + \" has already been mapped to a block (\" + this.GetBlockByID(ID).Identifier + \"). Try not specifying the ID to ensure that the block is given a unique Block ID.\");\r\n    }\r\n    else ID = this.FindSmallestID();\r\n    this.BlockIDMapping[ID] = Block;\r\n    this.BlockIdentifierMapping[Block.Identifier] = Block;\r\n    Block.ID = ID;\r\n  }\r\n  GetBlockByID(ID){\r\n    return this.BlockIDMapping[ID] ?? this.BlockIDMapping[49151];\r\n  }\r\n  GetBlockByIdentifier(Identifier){\r\n    return this.BlockIdentifierMapping[Identifier] ?? this.BlockIDMapping[49151];\r\n  }\r\n  FindSmallestID(){\r\n    for(let i = 0; i < BlockRegistry.MAX_BLOCK_IDS; i++){\r\n      if(this.BlockIDMapping[i] === undefined) return i;\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Block/BlockRegistry.mjs?");

/***/ }),

/***/ "./VoxelEngine/Libraries/DeferredPromise.mjs":
/*!***************************************************!*\
  !*** ./VoxelEngine/Libraries/DeferredPromise.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DeferredPromise)\n/* harmony export */ });\n/**\r\n * This is a wrapper around the standard Promise to allow for nicer syntax when deferring promise resolutions. Example use:\r\n * <pre>\r\n *   const Wait = new DeferredPromise;\r\n *    setTimeout(function(){\r\n *      Wait.resolve();\r\n *    }, 1000);\r\n *    await Wait;\r\n *    console.log(\"1 second passed\");\r\n * </pre>\r\n */\r\nclass DeferredPromise extends Promise{\r\n  /*static{\r\n    DeferredPromise.prototype.constructor = Promise;\r\n  }*/ //these aren't a thing yet\r\n  static #InitCaller = DeferredPromise.#StaticInit();\r\n  static #StaticInit(){\r\n    DeferredPromise.prototype.constructor = Promise;\r\n  }\r\n  constructor(Options = {}){\r\n    let resolve, reject;\r\n    super(function(Resolve, Reject){\r\n      resolve = Resolve;\r\n      reject = Reject;\r\n    });\r\n    this.resolve = resolve;\r\n    this.reject = reject;\r\n    if(Options.Timeout){\r\n      globalThis.setTimeout((Options.Throw ?? true ? this.reject : this.resolve).bind(this), +Options.Timeout);\r\n    }\r\n  }\r\n};\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Libraries/DeferredPromise.mjs?");

/***/ }),

/***/ "./VoxelEngine/Libraries/Listenable/Listenable.mjs":
/*!*********************************************************!*\
  !*** ./VoxelEngine/Libraries/Listenable/Listenable.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Listenable)\n/* harmony export */ });\nclass Listenable{\r\n  static Version = \"1.3\";\r\n  static Build = 4;\r\n  constructor(){\r\n    this.EventListeners = [];\r\n  }\r\n  AddEventListener(Event, Listener, Options = {\"TTL\": Infinity, \"Once\": false}){\r\n    if(this.EventListeners[Event] === undefined) this.EventListeners[Event] = [];\r\n    this.EventListeners[Event].push({\r\n      \"Event\": Event,\r\n      \"Listener\": Listener,\r\n      \"Options\": Options\r\n    });\r\n    return this.EventListeners[Event].length - 1;\r\n  }\r\n  RemoveEventListener(Event, ID){\r\n    this.EventListeners[Event].splice(ID, 1);\r\n  }\r\n  FireEventListeners(Event, ...Parameters){\r\n    const Listeners = this.EventListeners[Event];\r\n    if(Listeners === undefined) return;\r\n    const ListenersCopy = [];\r\n    for(let i = 0; i < Listeners.length; i++){\r\n      const Listener = Listeners[i].Listener;\r\n      if(!(this.EventListeners[Event][i].Options.TTL --> 0) || this.EventListeners[Event][i].Options.Once === true){\r\n        this.EventListeners[Event].splice(i--, 1);\r\n      }\r\n      ListenersCopy.push(Listener);\r\n    }\r\n    //This is done to avoid infinite loop if another event listener of the same name is added in the callback\r\n    for(const Listener of ListenersCopy) Listener(...Parameters);\r\n  }\r\n  on(...Args){\r\n    this.AddEventListener(...Args);\r\n  }\r\n};\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/Libraries/Listenable/Listenable.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/LoadManager/DataManager.mjs":
/*!*******************************************************!*\
  !*** ./VoxelEngine/World/LoadManager/DataManager.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeallocateData64Init\": () => (/* binding */ DeallocateData64Init),\n/* harmony export */   \"DeallocateData8Init\": () => (/* binding */ DeallocateData8Init)\n/* harmony export */ });\nfunction DeallocateData8Init(Data8, AllocationIndex, AllocationArray){\r\n  return function(Location64, x8, y8, z8){\r\n    const Location = Data8[(Location64 << 9) | (x8 << 6) | (y8 << 3) | z8];\r\n    if((Location & (1 << 31)) !== 0) return;\r\n    if((Location & (1 << 28)) === 0) { //Is not of uniform type\r\n      const DeallocIndex = Atomics.add(AllocationIndex, 1, 1) & (AllocationArray.length - 1);\r\n      Atomics.store(AllocationArray, DeallocIndex, Location);\r\n    }\r\n    Data8[(Location64 << 9) | (x8 << 6) | (y8 << 3) | z8] = 0x80000000;\r\n  };\r\n};\r\n\r\nfunction DeallocateData64Init(Data64, AllocationIndex64, AllocationArray64){\r\n  return function(Location64, x64, y64, z64, Depth){\r\n    if(((Data64[(Depth << 9) | (x64 << 6) | (y64 << 3) | z64] >> 31) & 1) === 1) return;\r\n    const DeallocIndex = Atomics.add(AllocationIndex64, 1, 1) & 4095; //Indexing 1 for deallocation.\r\n    Atomics.store(AllocationArray64, DeallocIndex, Location64); //Add location back to the allocation array to be reused.\r\n    Data64[(Depth << 9) | (x64 << 6) | (y64 << 3) | z64] = 1 << 31;\r\n  };\r\n};\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/LoadManager/DataManager.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/LoadManager/GPURegionDataLoader.mjs":
/*!***************************************************************!*\
  !*** ./VoxelEngine/World/LoadManager/GPURegionDataLoader.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GPURegionDataLoader)\n/* harmony export */ });\nclass GPURegionDataLoader{\r\n  constructor(LoadManager){\r\n    this.LoadManager = LoadManager;\r\n\r\n    void function Load(){\r\n      self.setTimeout(Load.bind(this), 75);\r\n      this.UpdateGPUData();\r\n    }.bind(this)();\r\n  }\r\n  AllocateSegment(Index64){\r\n    const SegmentLocation = this.LoadManager.FreeSegments.pop();\r\n    if(SegmentLocation === undefined) throw new Error(\"Ran out of segments!!\");\r\n    this.LoadManager.Data64SegmentAllocations[Index64].push(SegmentLocation);\r\n    return SegmentLocation;\r\n  }\r\n  AllocateGPUData64(Index64){\r\n    const Location64 = this.LoadManager.FreeGPUData64.pop();\r\n    if(Location64 === undefined) throw new Error(\"Ran out of GPU Data64!!\");\r\n    this.LoadManager.GPUInfo64[Index64] = Location64;\r\n    return Location64;\r\n  }\r\n  UpdateGPUData(){\r\n    const Data64 = this.LoadManager.Data64;\r\n    const Data8 = this.LoadManager.Data8;\r\n    const Data1 = this.LoadManager.Data1;\r\n    const VoxelTypes = this.LoadManager.VoxelTypes;\r\n    const GPUData64 = this.LoadManager.GPUData64;\r\n    const GPUData8 = this.LoadManager.GPUData8;\r\n    const GPUData1 = this.LoadManager.GPUData1;\r\n    const GPUInfo64 = this.LoadManager.GPUInfo64;\r\n    const GPUInfo8 = this.LoadManager.GPUInfo8;\r\n    const GPUType1 = this.LoadManager.GPUType1;\r\n    const GPUBoundingBox1 = this.LoadManager.GPUBoundingBox1;\r\n    const Data64SegmentAllocations = this.LoadManager.Data64SegmentAllocations;\r\n    const Data64SegmentIndices = this.LoadManager.Data64SegmentIndices;\r\n    for(let Depth = 0; Depth < 8; ++Depth) for(let x64 = 0; x64 < 8; x64++) for(let y64 = 0; y64 < 8; y64++) for(let z64 = 0; z64 < 8; z64++){\r\n      const Index64 = (Depth << 9) | (x64 << 6) | (y64 << 3) | z64;\r\n      const Info64 = Data64[Index64];\r\n\r\n      if(((Info64 >> 19) & 7) !== 7) continue; //Not fully loaded\r\n\r\n\r\n      if(((Info64 >> 31) & 1) === 1){ //Empty Data64\r\n        Data64[Index64] &= ~(1 << 30); //Toggle CPU update to false\r\n        GPUInfo64[Index64] |= 1 << 30; //Toggle GPU update to true\r\n        continue;\r\n      }\r\n\r\n      if(((Info64 >> 30) & 1) === 0) continue; //Doesn't need GPU update\r\n\r\n      //Data64[Index64] &= ~(1 << 30); //Toggle GPU update to false\r\n\r\n      const Location64 = Info64 & 0x0007ffff;\r\n      const RequiredIndex8 = new Set;\r\n      for(let x8 = 0; x8 < 8; x8++) for(let y8 = 0; y8 < 8; y8++) for(let z8 = 0; z8 < 8; z8++){\r\n        const Index8 = (Location64 << 9) | (x8 << 6) | (y8 << 3) | z8;\r\n        const Info8 = Data8[Index8];\r\n        if(((Info8 >> 31) & 1) === 1 || ((Info8 >> 29) & 3) === 0) continue; //Is all air or has no updates\r\n        Data8[Index8] &= ~(3 << 29); //Toggle updates to false\r\n        if(((Info8 >> 30) & 1) === 1){\r\n          let Required = false;\r\n          if(((Info8 >> 28) & 1) === 0){ //Does not have uniform type\r\n            const StartLocation1 = (Info8 & 0x0fffffff) << 6;\r\n            for (let i = StartLocation1; i < StartLocation1 + 64; ++i) { //TODO: Also check surroundings.\r\n              if (Data1[i] !== 0) { //This means that at least one of the blocks isn't solid, meaning that it has to be added.\r\n                Required = true;\r\n                RequiredIndex8.add(Index8);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          //TODO: What seems to be happening is that the data doesn't get updated because of ^^^ if the Data8 is completely full and the neighbour isn't completely empty\r\n\r\n          //Description: This marks Data8 parts that are fully solid but that are also exposed.\r\n          //FIXME: This probably doesn't work correctly for some circumstances on Data64 boundaries.\r\n          for(const [dx8, dy8, dz8] of [\r\n            [x8 - 1, y8, z8],\r\n            [x8 + 1, y8, z8],\r\n            [x8, y8 - 1, z8],\r\n            [x8, y8 + 1, z8],\r\n            [x8, y8, z8 - 1],\r\n            [x8, y8, z8 + 1]\r\n          ]){\r\n            const dx64 = x64 + Math.floor(dx8 / 8.);\r\n            if(dx64 < 0 || dx64 > 7) continue;\r\n            const dy64 = y64 + Math.floor(dy8 / 8.);\r\n            if(dy64 < 0 || dy64 > 7) continue;\r\n            const dz64 = z64 + Math.floor(dz8 / 8.);\r\n            if(dz64 < 0 || dz64 > 7) continue;\r\n            const dIndex64 = (Depth << 9) | ((dx64 & 7) << 6) | ((dy64 & 7) << 3) | (dz64 & 7);\r\n            if(((Data64[dIndex64] >> 31) & 1) === 1){\r\n              if(!Required && ((Data64[dIndex64] >> 19) & 7) >= 2) RequiredIndex8.add(Index8); //TODO: What does this mean??????????\r\n              continue;\r\n            }\r\n            //if(!Required) continue;\r\n            const dLocation64 = Data64[dIndex64] & 0x0007ffff;\r\n            const dIndex8 = (dLocation64 << 9) | ((dx8 & 7) << 6) | ((dy8 & 7) << 3) | (dz8 & 7);\r\n            const dInfo8 = Data8[dIndex8];\r\n            if(((dInfo8 >> 31) & 1) === 1){\r\n              if(!Required) RequiredIndex8.add(Index8);\r\n              continue;\r\n            }\r\n            if(!Required) continue;\r\n            if(dIndex64 === Index64){//Is within the same Location64, so it can be added straight to the update set\r\n              RequiredIndex8.add(dIndex8);\r\n            } else{\r\n              Data8[dIndex8] |= 1 << 29;\r\n              Data64[dIndex64] |= 1 << 30;\r\n            }\r\n          }\r\n        } else if(((Info8 >> 29) & 1) === 1) RequiredIndex8.add(Index8);\r\n      }\r\n      if(RequiredIndex8.size === 0) continue;\r\n      let GPULocation64 = GPUInfo64[Index64];\r\n      if(((GPULocation64 >> 31) & 1) === 1) GPULocation64 = this.AllocateGPUData64(Index64);\r\n      GPULocation64 &= 0x0fffffff;\r\n      const Segments = Data64SegmentAllocations[Index64];\r\n      if(Segments.length === 0) this.AllocateSegment(Index64);\r\n      for(let i = 0; i < 512; ++i){\r\n        const Index8 = (Location64 << 9) | i;\r\n        const GPUIndex8 = (GPULocation64 << 9) | i;\r\n        if(!RequiredIndex8.has(Index8)) continue;\r\n        //These are now going to get their data saved\r\n        let GPULocation1 = null;\r\n        const Index = Data64SegmentIndices[Index64]; //TODO: Don't have to do this for uniform data!!!###########\r\n        if(Index === 16){\r\n          const SegmentLocationStart = this.AllocateSegment(Index64);\r\n          GPULocation1 = SegmentLocationStart << 4;\r\n          Data64SegmentIndices[Index64] = 1;\r\n        } else{\r\n          const SegmentLocationStart = Segments[Segments.length - 1];\r\n          GPULocation1 = (SegmentLocationStart << 4) | Index;\r\n          Data64SegmentIndices[Index64]++;\r\n        }\r\n        //GPUDataLocation1 allocation done\r\n        GPUInfo8[GPUIndex8] = GPULocation1 | (1 << 30); //Set update flag\r\n        const Info8 = Data8[Index8];\r\n        const GPUData1Start = GPULocation1 << 6;\r\n        const GPUTypesStart = GPULocation1 << 9;\r\n        if(((Info8 >> 28) & 1) === 1){ //Has uniform type\r\n          const Type = Info8 & 0x0000ffff;\r\n          for(let i = 0; i < 64; ++i){\r\n            GPUData1[GPUData1Start | i] = 0; //TODO: Might have to revise this? It's probably fine for now\r\n          }\r\n          for(let i = 0; i < 512; ++i){\r\n            GPUType1[GPUTypesStart | i] = Type;\r\n          }\r\n          GPUBoundingBox1[GPUIndex8] = (0 << 15) | (0 << 12) | (0 << 9) | (7 << 6) | (7 << 3) | 7;\r\n        } else{ //Not uniform type, has saved data, copy it over\r\n          const Location8 = Data8[Index8] & 0x0fffffff;\r\n          const Data1Start = Location8 << 6;\r\n          const VoxelTypesStart = Location8 << 9;\r\n          for(let i = 0; i < 64; ++i){ //TODO: change this to .set if possible, https://stackoverflow.com/a/35563895\r\n            GPUData1[GPUData1Start | i] = Data1[Data1Start | i];\r\n          }\r\n          let MinX = 7;\r\n          let MinY = 7;\r\n          let MinZ = 7;\r\n          let MaxX = 0;\r\n          let MaxY = 0;\r\n          let MaxZ = 0;\r\n          for(let x = 0; x < 8; ++x) for(let y = 0; y < 8; ++y) for(let z = 0; z < 8; ++z){ //TODO: change this to .set if possible\r\n            const Type = VoxelTypes[VoxelTypesStart | (x << 6) | (y << 3) | z];\r\n            GPUType1[GPUTypesStart | (x << 6) | (y << 3) | z] = Type;\r\n\r\n            if(Type === 0) continue; //TODO: Make this work for all transparent blocks\r\n            if(MinX > x) MinX = x;\r\n            if(MinY > y) MinY = y;\r\n            if(MinZ > z) MinZ = z;\r\n            if(MaxX < x) MaxX = x;\r\n            if(MaxY < y) MaxY = y;\r\n            if(MaxZ < z) MaxZ = z;\r\n          }\r\n          MinX = Math.min(0, MinX);\r\n          MinY = Math.min(0, MinY);\r\n          MinZ = Math.min(1, MinZ);\r\n          for(let i = 0; i < 64; ++i){\r\n            GPUData1[GPUData1Start | i] = Data1[Data1Start | i];\r\n          }\r\n          GPUBoundingBox1[GPUIndex8] = (MinX << 15) | (MinY << 12) | (MinZ << 9) | (MaxX << 6) | (MaxY << 3) | MaxZ;\r\n          //GPUData8[GPUIndex8] |= (MaxX - MinX)\r\n        }\r\n      }\r\n      //Update GPUData8\r\n\r\n      for(let i = 0; i < 64; ++i){\r\n        const Info8Start = (GPULocation64 << 9) | (i << 3);\r\n        GPUData8[Info8Start >> 3] = 0; //This resets the bits so that the line below works correctly\r\n        for(let j = 0; j < 8; ++j){\r\n          GPUData8[Info8Start >> 3] |= ((GPUInfo8[Info8Start | j] >> 31) & 1) << j;\r\n        }\r\n      }\r\n\r\n\r\n      GPUInfo64[Index64] |= 1 << 30; //Set update flag for GPU (so that the new data is uploaded)\r\n      Data64[Index64] &= ~(1 << 29); //Request mesh update\r\n    }\r\n  }\r\n};\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/LoadManager/GPURegionDataLoader.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/LoadManager/LoadManager.mjs":
/*!*******************************************************!*\
  !*** ./VoxelEngine/World/LoadManager/LoadManager.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LoadManager)\n/* harmony export */ });\n/* harmony import */ var _RegionLoader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegionLoader.mjs */ \"./VoxelEngine/World/LoadManager/RegionLoader.mjs\");\n/* harmony import */ var _RegionUnloader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RegionUnloader.mjs */ \"./VoxelEngine/World/LoadManager/RegionUnloader.mjs\");\n/* harmony import */ var _RRSLoader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RRSLoader.mjs */ \"./VoxelEngine/World/LoadManager/RRSLoader.mjs\");\n/* harmony import */ var _RegionSD_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RegionSD.mjs */ \"./VoxelEngine/World/RegionSD.mjs\");\n/* harmony import */ var _Block_BlockRegistry_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Block/BlockRegistry.mjs */ \"./VoxelEngine/Block/BlockRegistry.mjs\");\n/* harmony import */ var _GPURegionDataLoader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GPURegionDataLoader.mjs */ \"./VoxelEngine/World/LoadManager/GPURegionDataLoader.mjs\");\n/* harmony import */ var _BackgroundTasks_SharedDebugData_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../BackgroundTasks/SharedDebugData.mjs */ \"./VoxelEngine/BackgroundTasks/SharedDebugData.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass LoadManager{\r\n  constructor(Data){\r\n    this.MainBlockRegistry = _Block_BlockRegistry_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Initialise(Data.BlockIDMapping, Data.BlockIdentifierMapping);\r\n\r\n    this.RequiredRegionsSelection = new Float64Array(new SharedArrayBuffer(8 * 12 * 33));\r\n\r\n    this.SharedDebugData = Data.SharedDebugData;\r\n\r\n    this.PlayerPosition = Data.SharedPlayerPosition;\r\n    this.Structures = Data.Structures;\r\n\r\n    this.AtlasRanges = Data.AtlasRanges;\r\n    this.AtlasWidth = Data.AtlasWidth;\r\n    this.AtlasHeight = Data.AtlasHeight;\r\n\r\n    this.VoxelTypes = Data.VoxelTypes;\r\n    this.Data1 = Data.Data1;\r\n    this.Data8 = Data.Data8;\r\n    this.Data64 = Data.Data64;\r\n\r\n    this.Data64Offset = Data.Data64Offset;\r\n\r\n    this.AllocationIndex = Data.AllocationIndex;\r\n    this.AllocationArray = Data.AllocationArray;\r\n    this.AllocationIndex64 = Data.AllocationIndex64;\r\n    this.AllocationArray64 = Data.AllocationArray64;\r\n\r\n    this.GPUData1 = Data.GPUData1;\r\n    this.GPUData8 = Data.GPUData8;\r\n    this.GPUData64 = Data.GPUData64;\r\n\r\n    this.GPUType1 = Data.GPUType1;\r\n    this.GPUInfo8 = Data.GPUInfo8;\r\n    this.GPUInfo64 = Data.GPUInfo64;\r\n    this.GPUBoundingBox1 = Data.GPUBoundingBox1;\r\n\r\n    this.LoadStageQueueLengths = Data.LoadStageQueueLengths;\r\n\r\n\r\n    this.FreeSegments = [];\r\n    for(let i = 0; i < 16384; ++i) this.FreeSegments.push(i);\r\n    self.EventHandler.GetFreeSegments = function(){\r\n      self.postMessage({\r\n        \"Request\": \"GetFreeSegments\",\r\n        \"Segments\": this.FreeSegments.length\r\n      });\r\n    }.bind(this);\r\n    //WARNING: This reference is NOT safe! ONLY INDEX THIS WITH .LoadManager.Data64SegmentAllocations!!!\r\n    this.Data64SegmentAllocations = new Array(8*8*8*8).fill().map(function(){return []});\r\n    this.Data64SegmentIndices = new Uint8Array(8*8*8*8);\r\n    this.FreeGPUData64 = [];\r\n    for(let i = 0; i < 4096; ++i) this.FreeGPUData64.push(i);\r\n\r\n    this.RegionLoader = new _RegionLoader_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\r\n    this.GPURegionDataLoader = new _GPURegionDataLoader_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this);\r\n    //this.RegionUnloader = new RegionUnloader(this);\r\n    this.RRSLoader = new _RRSLoader_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\r\n\r\n    void function Load() {\r\n      self.setTimeout(Load.bind(this), 100);\r\n      this.SharedDebugData[_BackgroundTasks_SharedDebugData_mjs__WEBPACK_IMPORTED_MODULE_6__.FREE_GPU_SEGMENTS] = this.FreeSegments.length;\r\n      this.SharedDebugData[_BackgroundTasks_SharedDebugData_mjs__WEBPACK_IMPORTED_MODULE_6__.MAX_GPU_SEGMENTS] = 16384;\r\n    }.bind(this)();\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/LoadManager/LoadManager.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/LoadManager/RRSLoader.mjs":
/*!*****************************************************!*\
  !*** ./VoxelEngine/World/LoadManager/RRSLoader.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RRSLoader)\n/* harmony export */ });\n/* harmony import */ var _RequiredRegionsSelectionSD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequiredRegionsSelectionSD.mjs */ \"./VoxelEngine/World/LoadManager/RequiredRegionsSelectionSD.mjs\");\n/* harmony import */ var _Region_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Region.mjs */ \"./VoxelEngine/World/Region.mjs\");\n/* harmony import */ var _DataManager_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DataManager.mjs */ \"./VoxelEngine/World/LoadManager/DataManager.mjs\");\n/* harmony import */ var _Libraries_DeferredPromise_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Libraries/DeferredPromise.mjs */ \"./VoxelEngine/Libraries/DeferredPromise.mjs\");\n/* harmony import */ var _Libraries_Listenable_Listenable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Libraries/Listenable/Listenable.mjs */ \"./VoxelEngine/Libraries/Listenable/Listenable.mjs\");\n\r\n\r\n\r\n\r\n\r\nclass RRSLoader{\r\n  constructor(LoadManager){\r\n    this.Events = new _Libraries_Listenable_Listenable_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\r\n    this.LoadManager = LoadManager;\r\n    this.Regions = LoadManager.Regions;\r\n    this.VirtualRegions = LoadManager.VirtualRegions;\r\n    this.Data64Offset = LoadManager.Data64Offset;\r\n    this.PlayerPosition = LoadManager.PlayerPosition;\r\n    this.Data8 = LoadManager.Data8;\r\n    this.Data64 = LoadManager.Data64;\r\n    this.GPUData8 = LoadManager.GPUData8;\r\n    this.GPUData64 = LoadManager.GPUData64;\r\n    this.GPUInfo8 = LoadManager.GPUInfo8;\r\n    this.GPUInfo64 = LoadManager.GPUInfo64;\r\n    this.AllocationIndex = LoadManager.AllocationIndex;\r\n    this.AllocationArray = LoadManager.AllocationArray;\r\n    this.AllocationIndex64 = LoadManager.AllocationIndex64;\r\n    this.AllocationArray64 = LoadManager.AllocationArray64;\r\n    this.LoadStageQueueLengths = LoadManager.LoadStageQueueLengths;\r\n\r\n    this.LoadingBatch = 0;\r\n\r\n    self.EventHandler[\"FinishedGPUDataTransfer\"] = function(){\r\n      this.Events.FireEventListeners(\"FinishedGPUDataTransfer\");\r\n    }.bind(this);\r\n\r\n    void async function Load(){\r\n      this.UpdateData64Offset();\r\n\r\n      const CurrentBatch = this.LoadRegions();\r\n\r\n      if(CurrentBatch !== -1){ //-1 means that no regions were requested because everything was already loaded.\r\n        const FinishedBatchPromise = new _Libraries_DeferredPromise_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\"Timeout\": 15000});\r\n        this.LoadManager.RegionLoader.Events.AddEventListener(\"FinishedLoadingBatch\", function (FinishedBatch){\r\n          if(CurrentBatch === FinishedBatch) FinishedBatchPromise.resolve();\r\n        });\r\n        console.time();\r\n        try{\r\n          await FinishedBatchPromise;\r\n        } catch(e){\r\n          console.warn(\"Batch generation is taking longer than 15000ms.\");\r\n        }\r\n        console.timeEnd();\r\n      }\r\n\r\n\r\n      //return;//############################\r\n      self.setTimeout(Load.bind(this), 25);\r\n    }.bind(this)();\r\n  }\r\n\r\n  DeallocateGPUData8(GPULocation64, x8, y8, z8){\r\n    const Index8 = (GPULocation64 << 9) | (x8 << 6) | (y8 << 3) | z8;\r\n    const Location8 = this.GPUData8[Index8];\r\n    //if(Location8 & (1 << 31)) return;\r\n    this.GPUInfo8[Index8] = 1 << 31;\r\n  }\r\n\r\n  DeallocateGPUData64(GPULocation64, Depth, x64, y64, z64){\r\n    const Index64 = (Depth << 9) | (x64 << 6) | (y64 << 3) | z64;\r\n    while(this.LoadManager.Data64SegmentAllocations[Index64].length > 0){\r\n      this.LoadManager.FreeSegments.push(this.LoadManager.Data64SegmentAllocations[Index64].pop());\r\n    }\r\n    this.LoadManager.FreeGPUData64.push(GPULocation64);\r\n    this.GPUInfo64[Index64] = 1 << 31;\r\n  }\r\n\r\n  UpdateData64Offset(){ //This is kinda messy but it works\r\n\r\n    const PlayerX = this.PlayerPosition[0];\r\n    const PlayerY = this.PlayerPosition[1];\r\n    const PlayerZ = this.PlayerPosition[2];\r\n\r\n    let Changed = false;\r\n\r\n    const NewData64Offset = new Int32Array(24);\r\n\r\n    for(let Depth = 0; Depth < 8; ++Depth){\r\n      const Size = 64 << Depth;\r\n\r\n      const XMin = Math.ceil((Math.floor(PlayerX / Size) - 4) / 2) * 2;\r\n      const YMin = Math.ceil((Math.floor(PlayerY / Size) - 4) / 2) * 2;\r\n      const ZMin = Math.ceil((Math.floor(PlayerZ / Size) - 4) / 2) * 2;\r\n\r\n      if(XMin - this.Data64Offset[Depth * 3 + 0] !== 0) Changed = true;\r\n      if(YMin - this.Data64Offset[Depth * 3 + 1] !== 0) Changed = true;\r\n      if(ZMin - this.Data64Offset[Depth * 3 + 2] !== 0) Changed = true;\r\n\r\n      NewData64Offset[Depth * 3 + 0] = XMin;\r\n      NewData64Offset[Depth * 3 + 1] = YMin;\r\n      NewData64Offset[Depth * 3 + 2] = ZMin;\r\n    }\r\n    //if(!Changed) return; //#######################\r\n\r\n    //Shift references of Data64:\r\n    const NewData64 = new Uint32Array(8*8*8*8).fill(0x80000000); //Sets it to be empty (and unloaded)\r\n    const NewGPUInfo64 = new Uint32Array(8*8*8*8).fill(0x80000000);\r\n    const NewData64SegmentAllocations = new Array(8*8*8*8).fill(null); //nulls will later be replaced with empty arrays\r\n    const NewData64SegmentIndices = new Uint8Array(8*8*8*8);\r\n\r\n    const DeallocateData8 = _DataManager_mjs__WEBPACK_IMPORTED_MODULE_2__.DeallocateData8Init(this.Data8, this.AllocationIndex, this.AllocationArray);\r\n    const DeallocateData64 = _DataManager_mjs__WEBPACK_IMPORTED_MODULE_2__.DeallocateData64Init(this.Data64, this.AllocationIndex64, this.AllocationArray64, this.Data64Offset);\r\n\r\n    for(let Depth = 0; Depth < 8; ++Depth){\r\n      const ChangeX = NewData64Offset[Depth * 3 + 0] - this.Data64Offset[Depth * 3 + 0];\r\n      const ChangeY = NewData64Offset[Depth * 3 + 1] - this.Data64Offset[Depth * 3 + 1];\r\n      const ChangeZ = NewData64Offset[Depth * 3 + 2] - this.Data64Offset[Depth * 3 + 2];\r\n\r\n      for(let rx64 = 0; rx64 < 8; rx64++){\r\n        const tx64 = rx64 - ChangeX;\r\n        for(let ry64 = 0; ry64 < 8; ry64++){\r\n          const ty64 = ry64 - ChangeY;\r\n          for(let rz64 = 0; rz64 < 8; rz64++){\r\n            const tz64 = rz64 - ChangeZ;\r\n            if(tx64 < 0 || tx64 >= 8 || ty64 < 0 || ty64 >= 8 || tz64 < 0 || tz64 >= 8){\r\n              //if(Depth !== 0) continue;\r\n              const Index64 = (Depth << 9) | (rx64 << 6) | (ry64 << 3) | rz64;\r\n              const Info64 = this.Data64[Index64];\r\n              const GPUInfo64 = this.GPUInfo64[Index64];\r\n              if(((Info64 >> 31) & 1) === 0){ //Data64 actually exists so it can be unloaded\r\n                const Location64 = Info64 & 0x0007ffff;\r\n                //Free Data8 references\r\n                for(let i = 0; i < 512; ++i){\r\n                  DeallocateData8(Location64, i >> 6, (i >> 3) & 7, i & 7);\r\n                }\r\n                DeallocateData64(Location64, rx64, ry64, rz64, Depth); //Free Data64 reference\r\n                //The Data1 and VoxelData references shouldn't matter, as they will probably get overwritten upon reallocation.\r\n              }\r\n              if((GPUInfo64 >> 31) === 0){ //GPUData64 actually exists so it can be unloaded\r\n                const GPULocation64 = this.GPUInfo64[Index64] & 0x0fffffff;\r\n                for(let i = 0; i < 512; ++i){\r\n                  this.DeallocateGPUData8(GPULocation64, i >> 6, (i >> 3) & 7, i & 7);\r\n                }\r\n                for(let i = 0; i < 64; ++i){\r\n                  this.GPUData8[(GPULocation64 << 6) | i] = 0xff;\r\n                }\r\n                this.DeallocateGPUData64(GPULocation64, Depth, rx64, ry64, rz64); //Also handles segment deallocation\r\n              }\r\n            } else{ //Move Data64 references\r\n              const TIndex64 = (Depth << 9) | (tx64 << 6) | (ty64 << 3) | tz64;\r\n              const RIndex64 = (Depth << 9) | (rx64 << 6) | (ry64 << 3) | rz64;\r\n              NewData64[TIndex64] = this.Data64[RIndex64];\r\n              NewGPUInfo64[TIndex64] = this.GPUInfo64[RIndex64];\r\n              NewData64SegmentAllocations[TIndex64] = this.LoadManager.Data64SegmentAllocations[RIndex64];\r\n              NewData64SegmentIndices[TIndex64] = this.LoadManager.Data64SegmentIndices[RIndex64];\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    this.GPUData64.fill(0);\r\n    for(let i = 0; i < 512; ++i) for(let j = 0; j < 8; ++j){\r\n      //This makes the region \"non-empty\" if it's actually non-empty, or if it's empty but the data has not been loaded yet.\r\n      this.GPUData64[i] |= (((this.GPUInfo64[(i << 3) | j] >> 31) & 1)) << j;// & (~(this.GPUInfo64[(i << 3) | j] >> 29) & 1)) << j;\r\n    }\r\n\r\n    //Set changes\r\n    //TODO: I'll probably need to make a mutex lock for this to make it thread-safe, although .set is quite fast\r\n\r\n    this.GPUInfo64.set(NewGPUInfo64, 0);\r\n    this.Data64Offset.set(NewData64Offset, 0);\r\n    this.Data64.set(NewData64, 0);\r\n\r\n    for(let i = 0, Length = NewData64SegmentAllocations.length; i < Length; ++i) if(NewData64SegmentAllocations[i] === null) NewData64SegmentAllocations[i] = [];\r\n    this.LoadManager.Data64SegmentAllocations = NewData64SegmentAllocations;\r\n    this.LoadManager.Data64SegmentIndices.set(NewData64SegmentIndices);\r\n\r\n    self.postMessage({\r\n      \"Request\": \"UpdatedData64Offset\"\r\n    });\r\n  }\r\n\r\n  LoadRegions(){\r\n    const RequestedRegions = [];\r\n    for(let Depth = 0; Depth < 8; ++Depth) for(let rx64 = 0; rx64 < 8; rx64++) for(let ry64 = 0; ry64 < 8; ry64++) for(let rz64 = 0; rz64 < 8; rz64++){\r\n      const Index = (Depth << 9) | (rx64 << 6) | (ry64 << 3) | rz64;\r\n      const State = (this.Data64[Index] >> 19) & 7;\r\n      if(State === 0){ //This means that it's not started loading.\r\n        this.Data64[Index] = (this.Data64[Index] & ~(7 << 19)) | (1 << 19); //Set state to 1 (Started loading)\r\n        const RegionX = rx64 + this.Data64Offset[Depth * 3 + 0];\r\n        const RegionY = ry64 + this.Data64Offset[Depth * 3 + 1];\r\n        const RegionZ = rz64 + this.Data64Offset[Depth * 3 + 2];\r\n        RequestedRegions.push([Depth, RegionX, RegionY, RegionZ]);\r\n      }\r\n    }\r\n    if(RequestedRegions.length > 0){\r\n      this.LoadManager.FinishedStage2Batch = -1;\r\n    }\r\n    for(const [Depth, RegionX, RegionY, RegionZ] of RequestedRegions){\r\n      if(Depth === 0) this.LoadManager.RegionLoader.Stage1(RegionX, RegionY, RegionZ, this.LoadingBatch, RequestedRegions.length);\r\n      else this.LoadManager.RegionLoader.VirtualStage1(RegionX, RegionY, RegionZ, Depth, this.LoadingBatch, RequestedRegions.length);\r\n      //I need to pass the batch size (last parameter) so that I know when the batch has finished loading.\r\n    }\r\n    if(RequestedRegions.length > 0) return this.LoadingBatch++;\r\n    else return -1;\r\n  }\r\n};\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/LoadManager/RRSLoader.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/LoadManager/RegionLoader.mjs":
/*!********************************************************!*\
  !*** ./VoxelEngine/World/LoadManager/RegionLoader.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RegionLoader)\n/* harmony export */ });\n/* harmony import */ var _Region_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Region.mjs */ \"./VoxelEngine/World/Region.mjs\");\n/* harmony import */ var _Libraries_Listenable_Listenable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Libraries/Listenable/Listenable.mjs */ \"./VoxelEngine/Libraries/Listenable/Listenable.mjs\");\n/* harmony import */ var _RegionSD_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../RegionSD.mjs */ \"./VoxelEngine/World/RegionSD.mjs\");\n/* harmony import */ var _RequiredRegionsSelectionSD_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RequiredRegionsSelectionSD.mjs */ \"./VoxelEngine/World/LoadManager/RequiredRegionsSelectionSD.mjs\");\n\r\n\r\n\r\n\r\n\r\nclass RegionLoader{\r\n  static GetDistancedPointMap(){\r\n    function* RandomPointGenerator(Seed){\r\n      while(true) yield (Seed = Seed * 0x41a7 % 0x7fffffff) / 0x7fffffff;\r\n    }\r\n\r\n    function GetRandomPointsFor(RegionX, RegionZ){\r\n      RegionX &= 15;\r\n      RegionZ &= 15;\r\n\r\n      const RNG = RandomPointGenerator(RegionX * 8 + RegionZ + 1); //The +1 is because the random point generator fails with seed 0.\r\n      const Points = [];\r\n      for(let i = 0; i < 30; i++){\r\n        const X = Math.floor(RNG.next().value * 64);\r\n        const Z = Math.floor(RNG.next().value * 64);\r\n        Points.push({\"X\": X, \"Z\": Z});\r\n      }\r\n      return Points;\r\n    }\r\n\r\n    function GetAllNearbyPoints(RegionX, RegionZ, Density){\r\n      const Points = [];\r\n      for(let rX = RegionX - 1; rX < RegionX + 2; rX++) for(let rZ = RegionZ - 1; rZ < RegionZ + 2; rZ++) {\r\n        Points.push(...PointGenerator(rX, rZ, Density));\r\n      }\r\n\r\n      return Points;\r\n    }\r\n\r\n    const RandomPointMap = {};\r\n\r\n    for(const i of [6, 10, 15]){\r\n      RandomPointMap[i] = {};\r\n      let DensityObject = RandomPointMap[i];\r\n      for(let RegionX = 0; RegionX < 8; RegionX++) for(let RegionZ = 0; RegionZ < 8; RegionZ++){\r\n        const Identifier = RegionX * 8 + RegionZ;\r\n        DensityObject[Identifier] = GetRandomPointsFor(RegionX, RegionZ);\r\n      }\r\n    }\r\n\r\n    function* PointGenerator(RegionX, RegionZ, Density){\r\n      const RNG = RandomPointGenerator((RegionX & 7) * 8 + (RegionZ & 7) + 1); //The +1 is because the random point generator fails with seed 0.\r\n      const DensityObject = RandomPointMap[Density];\r\n\r\n      const Points = [];\r\n      for(let dX = -1; dX < 2; dX++) for(let dZ = -1; dZ < 2; dZ++){\r\n        const rX = dX + RegionX;\r\n        const rZ = dZ + RegionZ;\r\n        if(rX === RegionX && rZ === RegionZ) continue;\r\n        const NewPoints = [...DensityObject[(rX & 7) * 8 + (rZ & 7)]];\r\n        for(const {X, Z} of NewPoints) Points.push({\"X\": X + Math.sign(dX) * 64, \"Z\": Z + Math.sign(dZ) * 64});\r\n      }\r\n\r\n      const DensitySquared = Density ** 2;\r\n\r\n      let GeneratorAttempts = 0;\r\n      while(GeneratorAttempts++ < 10){\r\n        let ValidatorAttempts = 0;\r\n        PointValidator: while(ValidatorAttempts++ < 10){\r\n          const X = Math.floor(RNG.next().value * 64);\r\n          const Z = Math.floor(RNG.next().value * 64);\r\n\r\n          for(const Point of Points){\r\n            const DistanceSquared = (X - Point.X) ** 2 + (Z - Point.Z) ** 2;\r\n            if(DistanceSquared < DensitySquared) continue PointValidator;\r\n          }\r\n          const Point = {\"X\": X, \"Z\": Z};\r\n          Points.push(Point);\r\n          yield Point;\r\n          GeneratorAttempts = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    const DistancedPointMap = {};\r\n\r\n    for(const Density of [6, 10, 15]){\r\n      DistancedPointMap[Density] = {};\r\n      let DensityObject = DistancedPointMap[Density];\r\n      for(let RegionX = 0; RegionX < 8; RegionX++) for(let RegionZ = 0; RegionZ < 8; RegionZ++){\r\n        const Identifier = RegionX * 8 + RegionZ;\r\n        DensityObject[Identifier] = [...PointGenerator(RegionX, RegionZ, Density)];\r\n      }\r\n    }\r\n\r\n    return DistancedPointMap;\r\n  }\r\n\r\n  constructor(LoadManager){\r\n    this.Events = new _Libraries_Listenable_Listenable_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\r\n    this.LoadManager = LoadManager;\r\n    this.HeightMaps = {};\r\n    this.DistancedPointMap = RegionLoader.GetDistancedPointMap();\r\n\r\n    this.VoxelTypes = LoadManager.VoxelTypes;\r\n    this.Data1 = LoadManager.Data1;\r\n    this.Data8 = LoadManager.Data8;\r\n    this.Data64 = LoadManager.Data64;\r\n\r\n    this.GPUInfo8 = LoadManager.GPUInfo8;\r\n    this.GPUInfo64 = LoadManager.GPUInfo64;\r\n    this.GPUBoundingBox1 = LoadManager.GPUBoundingBox1;\r\n\r\n    this.Data64Offset = LoadManager.Data64Offset;\r\n\r\n    this.AllocationIndex = LoadManager.AllocationIndex;\r\n    this.AllocationArray = LoadManager.AllocationArray;\r\n    this.AllocationIndex64 = LoadManager.AllocationIndex64;\r\n    this.AllocationArray64 = LoadManager.AllocationArray64;\r\n\r\n    this.WorkerHeightMapGenerator = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"VoxelEngine_MultiWorkerHeightMapGeneratorManager_mjs\"), __webpack_require__.b), {\"name\": \"Heightmap Generator Manager\"});\r\n    this.WorkerRegionGenerator = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"VoxelEngine_MultiWorkerRegionGeneratorManager_mjs\"), __webpack_require__.b), {\"name\": \"Region Generator Manager\"});\r\n    this.WorkerRegionDecorator = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"VoxelEngine_RegionDecoratorThreadPool_mjs\"), __webpack_require__.b), {\"name\": \"Region Decorator Thread Pool\"});\r\n    this.WorkerGeometryDataGenerator = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"VoxelEngine_MultiWorkerGeometryDataGeneratorManager_mjs\"), __webpack_require__.b), {\"name\": \"Geometry Data Generator Manager\"});\r\n\r\n    //Gets reset in RRSLoader\r\n    this.FinishedStage2Batch = -1;\r\n\r\n\r\n    this.Structures = this.LoadManager.Structures;\r\n    this.MainBlockRegistry = this.LoadManager.MainBlockRegistry;\r\n    this.ForeignMapping = {\r\n      \"biomesoplenty:leaves_4:2\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:leaves\").ID,\r\n      \"biomesoplenty:log_2\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:wood\").ID,\r\n      \"biomesoplenty:log_2:8\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:wood\").ID,\r\n      \"minecraft:spruce_log\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:wood\").ID,\r\n      \"minecraft:spruce_leaves\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:leaves\").ID,\r\n      \"minecraft:oak_log\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:oak_wood\").ID,\r\n      \"minecraft:oak_leaves\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:oak_leaves\").ID,\r\n      \"NotFound\": this.MainBlockRegistry.GetBlockByIdentifier(\"primary:error\").ID,\r\n      \"LOG\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:oak_wood\").ID,\r\n      \"LEAVES\": this.MainBlockRegistry.GetBlockByIdentifier(\"default:oak_leaves\").ID\r\n    };\r\n\r\n\r\n    //Initialise Workers\r\n\r\n    //HeightMap init\r\n\r\n    this.WorkerHeightMapGenerator.postMessage({\r\n      \"Request\": \"TransferRRS\",\r\n      \"RequiredRegionsSelection\": this.LoadManager.RequiredRegionsSelection\r\n    });\r\n    this.WorkerHeightMapGenerator.postMessage({\r\n      \"Request\": \"SetSeed\",\r\n      \"Seed\": 17\r\n    });\r\n\r\n    this.WorkerHeightMapGenerator.addEventListener(\"message\", function(Event){\r\n      const VerticalIdentifier = Event.data.RegionX + \",\" + Event.data.RegionZ + ((Event.data.Depth !== 0) ? (\",\" + Event.data.Depth) : \"\");\r\n      switch(Event.data.Request){\r\n        case \"SaveHeightMap\":{\r\n          this.HeightMaps[VerticalIdentifier] = {\r\n            \"HeightMap\": Event.data.HeightMap,\r\n            \"SlopeMap\": Event.data.SlopeMap,\r\n            \"TemperatureMap\": Event.data.TemperatureMap,\r\n            \"MinHeight\": Event.data.MinHeight,\r\n            \"MaxHeight\": Event.data.MaxHeight\r\n          };\r\n          this.Events.FireEventListeners(\"GeneratedHeightMap\" + VerticalIdentifier, Event);\r\n          break;\r\n        }\r\n      }\r\n    }.bind(this));\r\n\r\n    //Generator init\r\n\r\n    this.WorkerRegionGenerator.postMessage({\r\n      \"Request\": \"TransferRRS\",\r\n      \"RequiredRegionsSelection\": this.LoadManager.RequiredRegionsSelection\r\n    });\r\n\r\n    this.WorkerRegionGenerator.postMessage({\r\n      \"Request\": \"InitialiseBlockRegistry\",\r\n      \"BlockIDMapping\": this.LoadManager.MainBlockRegistry.BlockIDMapping,\r\n      \"BlockIdentifierMapping\": this.LoadManager.MainBlockRegistry.BlockIdentifierMapping\r\n    });\r\n\r\n    this.WorkerRegionGenerator.postMessage({\r\n      \"Request\": \"ShareStructures\",\r\n      \"Structures\": this.LoadManager.Structures,\r\n      \"ForeignMapping\": this.ForeignMapping\r\n    });\r\n\r\n    this.WorkerRegionGenerator.postMessage({\r\n      \"Request\": \"SaveDistancedPointMap\",\r\n      \"DistancedPointMap\": this.DistancedPointMap\r\n    });\r\n\r\n    this.WorkerRegionGenerator.postMessage({\r\n      \"Request\": \"ShareDataBuffers\",\r\n      \"Data1\": this.Data1,\r\n      \"Data8\": this.Data8,\r\n      \"Data64\": this.Data64,\r\n      \"VoxelTypes\": this.VoxelTypes,\r\n      \"Data64Offset\": this.Data64Offset,\r\n      \"AllocationIndex\": this.AllocationIndex,\r\n      \"AllocationArray\": this.AllocationArray,\r\n      \"AllocationIndex64\": this.AllocationIndex64,\r\n      \"AllocationArray64\": this.AllocationArray64\r\n    });\r\n\r\n    this.WorkerRegionGenerator.addEventListener(\"message\", function(Event){\r\n      switch(Event.data.Request){\r\n        case \"GeneratedRegionData\":{\r\n\r\n          break;\r\n        }\r\n        case \"FinishedLoadingBatch\":{\r\n          this.FinishedStage2Batch = Event.data.LoadingBatch;\r\n          this.TryFinishingBatch(false);\r\n          break;\r\n        }\r\n        case \"SaveVirtualRegionData\":{\r\n\r\n          break;\r\n        }\r\n      }\r\n    }.bind(this));\r\n\r\n    //Decorator init\r\n\r\n    this.WorkerRegionDecorator.postMessage({\r\n      \"Request\": \"TransferRRS\",\r\n      \"RequiredRegionsSelection\": this.LoadManager.RequiredRegionsSelection\r\n    });\r\n\r\n    this.WorkerRegionDecorator.postMessage({\r\n      \"Request\": \"InitialiseBlockRegistry\",\r\n      \"BlockIDMapping\": this.LoadManager.MainBlockRegistry.BlockIDMapping,\r\n      \"BlockIdentifierMapping\": this.LoadManager.MainBlockRegistry.BlockIdentifierMapping\r\n    });\r\n\r\n    this.WorkerRegionDecorator.postMessage({\r\n      \"Request\": \"ShareStructures\",\r\n      \"Structures\": this.LoadManager.Structures,\r\n      \"ForeignMapping\": this.ForeignMapping\r\n    });\r\n\r\n    this.WorkerRegionDecorator.postMessage({\r\n      \"Request\": \"SaveDistancedPointMap\",\r\n      \"DistancedPointMap\": this.DistancedPointMap\r\n    });\r\n\r\n    this.WorkerRegionDecorator.postMessage({\r\n      \"Request\": \"ShareDataBuffers\",\r\n      \"Data1\": this.Data1,\r\n      \"Data8\": this.Data8,\r\n      \"Data64\": this.Data64,\r\n      \"VoxelTypes\": this.VoxelTypes,\r\n      \"Data64Offset\": this.Data64Offset,\r\n      \"AllocationIndex\": this.AllocationIndex,\r\n      \"AllocationArray\": this.AllocationArray,\r\n      \"AllocationIndex64\": this.AllocationIndex64,\r\n      \"AllocationArray64\": this.AllocationArray64\r\n    });\r\n\r\n    this.WorkerRegionDecorator.addEventListener(\"message\", function(Event){\r\n      switch(Event.data.Request){\r\n        case \"Finished\":{\r\n          Atomics.sub(this.LoadManager.LoadStageQueueLengths, 3, 1);\r\n          if(this.FinishedStage2Batch !== -1){\r\n            this.TryFinishingBatch(false);\r\n          }\r\n          break;\r\n        }\r\n        default:{\r\n          throw new Error(Event.data.Request + \" is not supported.\");\r\n          break;\r\n        }\r\n      }\r\n    }.bind(this));\r\n\r\n    this.WorkerGeometryDataGenerator.postMessage({\r\n      \"Request\": \"SaveStuff\",\r\n      \"MaxWorkers\": 3,\r\n      \"VoxelTypes\": this.VoxelTypes,\r\n      \"Data8\": this.Data8,\r\n      \"GPUBoundingBox1\": this.GPUBoundingBox1,\r\n      \"GPUInfo8\": this.GPUInfo8,\r\n      \"GPUInfo64\": this.GPUInfo64,\r\n      \"Data64\": this.Data64,\r\n      \"Data64Offset\": this.Data64Offset\r\n    });\r\n\r\n    this.WorkerGeometryDataGenerator.onmessage = function(Event){\r\n      switch(Event.data.Request){\r\n        case \"GenerateBoundingGeometry\":{\r\n          self.postMessage(Event.data, [Event.data.Info.buffer]);\r\n          Atomics.sub(this.LoadManager.LoadStageQueueLengths, 4, 1);\r\n          this.TryFinishingBatch(true);\r\n          break;\r\n        }\r\n      }\r\n    }.bind(this);\r\n\r\n    void function Load(){\r\n      self.setTimeout(Load.bind(this), 50);\r\n      this.CheckStage4Eligibility();\r\n    }.bind(this)();\r\n  }\r\n  TryFinishingBatch(SkipChecks){\r\n    if(!SkipChecks){\r\n      this.CheckStage3Eligibility();\r\n      this.LoadManager.GPURegionDataLoader.UpdateGPUData();\r\n      this.CheckStage4Eligibility();\r\n    }\r\n    //console.log(this.LoadManager.LoadStageQueueLengths[3], this.LoadManager.LoadStageQueueLengths[4]);\r\n    if(this.FinishedStage2Batch !== -1 && Atomics.load(this.LoadManager.LoadStageQueueLengths, 3) === 0 && Atomics.load(this.LoadManager.LoadStageQueueLengths, 4) === 0){\r\n      this.Events.FireEventListeners(\"FinishedLoadingBatch\", this.FinishedStage2Batch);\r\n      self.postMessage({\r\n        \"Request\": \"FinishedLoadingBatch\",\r\n        \"Batch\": this.FinishedStage2Batch\r\n      });\r\n    }\r\n  }\r\n  //Generate heightmap\r\n  Stage1(RegionX, RegionY, RegionZ, LoadingBatch = -1, BatchSize = 1){\r\n    const Identifier = RegionX + \",\" + RegionY + \",\" + RegionZ;\r\n    const VerticalIdentifier = RegionX + \",\" + RegionZ;\r\n\r\n    const HeightMap = this.HeightMaps[VerticalIdentifier];\r\n\r\n    if(HeightMap){\r\n      this.Stage2(RegionX, RegionY, RegionZ, LoadingBatch, BatchSize);\r\n    } else{\r\n      if(HeightMap === undefined){ //It can also be null, in which case generation of the heightmap has already started, but has not finished.\r\n        this.HeightMaps[VerticalIdentifier] = null; //To show that the heightmap has started generating so it doesn't generate again.\r\n        this.WorkerHeightMapGenerator.postMessage({\r\n          \"Request\": \"GenerateHeightMap\",\r\n          \"RegionX\": RegionX,\r\n          \"RegionZ\": RegionZ,\r\n          \"XLength\": 64,\r\n          \"ZLength\": 64,\r\n          \"GenerateSlopeMap\": true,\r\n          \"Depth\": 0\r\n        });\r\n      }\r\n      this.Events.AddEventListener(\"GeneratedHeightMap\" + VerticalIdentifier, function(){\r\n        this.Stage2(RegionX, RegionY, RegionZ, LoadingBatch, BatchSize);\r\n      }.bind(this), {\"Once\": true});\r\n    }\r\n  }\r\n\r\n  //Generate region data\r\n  Stage2(RegionX, RegionY, RegionZ, LoadingBatch, BatchSize){\r\n    const VerticalIdentifier = RegionX + \",\" + RegionZ;\r\n\r\n    const HeightMap = this.HeightMaps[VerticalIdentifier];\r\n\r\n    if(!HeightMap) return; //The heightmap has been unloaded, which means that the region is also not needed anymore.\r\n\r\n    //Progression to Stage 3 is managed in the constructor.\r\n    this.WorkerRegionGenerator.postMessage({\r\n      \"Request\": \"GenerateRegionData\",\r\n      \"RegionX\": RegionX,\r\n      \"RegionY\": RegionY,\r\n      \"RegionZ\": RegionZ,\r\n      \"HeightMap\": HeightMap.HeightMap,\r\n      \"SlopeMap\": HeightMap.SlopeMap,\r\n      \"TemperatureMap\": HeightMap.TemperatureMap,\r\n      \"MaxHeight\": HeightMap.MaxHeight,\r\n      \"MinHeight\": HeightMap.MinHeight,\r\n      \"LoadingBatch\": LoadingBatch,\r\n      \"BatchSize\": BatchSize\r\n    });\r\n  }\r\n\r\n  CheckStage3Eligibility(){\r\n    //return;\r\n    //Iterating from 1 to 6 because 0 and 7 are definitely going to have missing neighbours (since they're on the border)\r\n    for(let rx64 = 1; rx64 < 7; rx64++) for(let ry64 = 1; ry64 < 7; ry64++){\r\n      RegionIterator: for(let rz64 = 1; rz64 < 7; rz64++) {\r\n        const MainIndex = (rx64 << 6) | (ry64 << 3) | rz64;\r\n        const LoadState = (this.Data64[MainIndex] >> 19) & 7;\r\n        if(LoadState !== 2){ //TODO: Or if it's empty, or if it has a single voxel type\r\n          continue;\r\n        }\r\n\r\n        for(let dx64 = rx64 - 1; dx64 < rx64 + 2; dx64++) for(let dz64 = rz64 - 1; dz64 < rz64 + 2; dz64++){\r\n          for(let dy64 = ry64 - 1; dy64 < ry64 + 2; dy64++){\r\n            const LoadState = (this.Data64[(dx64 << 6) | (dy64 << 3) | dz64] >> 19) & 7;\r\n            if(LoadState < 2) continue RegionIterator; //This might not actually be that important\r\n          }\r\n        }\r\n        this.Data64[MainIndex] = (this.Data64[MainIndex] & ~(7 << 19)) | (3 << 19); //Set state to 3 (Started stage 3)\r\n\r\n\r\n        const RegionX = this.Data64Offset[0] + rx64;\r\n        const RegionY = this.Data64Offset[1] + ry64;\r\n        const RegionZ = this.Data64Offset[2] + rz64;\r\n\r\n        const Maps = this.HeightMaps[RegionX + \",\" + RegionZ];\r\n        Atomics.add(this.LoadManager.LoadStageQueueLengths, 3, 1);\r\n        this.WorkerRegionDecorator.postMessage({\r\n          \"Request\": \"DecorateRegion\",\r\n          \"RegionX\": RegionX,\r\n          \"RegionY\": RegionY,\r\n          \"RegionZ\": RegionZ,\r\n          \"Maps\": Maps\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  //This is done for both normal and virtual regions:\r\n  CheckStage4Eligibility(){\r\n    for(let Depth = 0; Depth < 8; ++Depth){\r\n      for(let x64 = 0; x64 < 8; ++x64) for(let y64 = 0; y64 < 8; ++y64) for(let z64 = 0; z64 < 8; ++z64){\r\n        const Index64 = (Depth << 9) | (x64 << 6) | (y64 << 3) | z64;\r\n\r\n        const Region64X = x64 + this.Data64Offset[3 * Depth + 0];\r\n        const Region64Y = y64 + this.Data64Offset[3 * Depth + 1];\r\n        const Region64Z = z64 + this.Data64Offset[3 * Depth + 2];\r\n\r\n        const GPUInfo64 = this.GPUInfo64[Index64];\r\n        const Info64 = this.Data64[Index64];\r\n\r\n        //GPU region is empty, or has not been fully uploaded, or the load state is too low, or the mesh is already being generated or has been generated.\r\n        if(((GPUInfo64 >> 31) & 1) === 1 || ((Info64 >> 19) & 7) !== 7 || ((Info64 >> 29) & 1) === 1) continue;\r\n        this.Data64[Index64] |= 1 << 29;\r\n        Atomics.add(this.LoadManager.LoadStageQueueLengths, 4, 1);\r\n        this.WorkerGeometryDataGenerator.postMessage({\r\n          \"Request\": \"GenerateBoundingGeometry\",\r\n          \"RegionX\": Region64X,\r\n          \"RegionY\": Region64Y,\r\n          \"RegionZ\": Region64Z,\r\n          \"Depth\": Depth,\r\n          \"Time\": self.performance.now()\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  //Virtual regions\r\n\r\n  VirtualStage1(RegionX, RegionY, RegionZ, Depth, LoadingBatch = -1, BatchSize = 1){\r\n    const VerticalIdentifier = RegionX + \",\" + RegionZ + \",\" + Depth;\r\n\r\n    const HeightMap = this.HeightMaps[VerticalIdentifier];\r\n\r\n    if(HeightMap){\r\n      this.VirtualStage2(RegionX, RegionY, RegionZ, Depth, LoadingBatch, BatchSize);\r\n    } else{\r\n      if(HeightMap === undefined){ //It can also be null, in which case generation of the heightmap has already started, but has not finished.\r\n        this.HeightMaps[VerticalIdentifier] = null; //To show that the heightmap has started generating so it doesn't generate again.\r\n        this.WorkerHeightMapGenerator.postMessage({\r\n          \"Request\": \"GenerateHeightMap\",\r\n          \"RegionX\": RegionX,\r\n          \"RegionZ\": RegionZ,\r\n          \"XLength\": 64,\r\n          \"ZLength\": 64,\r\n          \"GenerateSlopeMap\": true,\r\n          \"Depth\": Depth\r\n        });\r\n      }\r\n      this.Events.AddEventListener(\"GeneratedHeightMap\" + VerticalIdentifier, function(){\r\n        this.VirtualStage2(RegionX, RegionY, RegionZ, Depth, LoadingBatch, BatchSize);\r\n      }.bind(this), {\"Once\": true});\r\n    }\r\n  }\r\n  VirtualStage2(RegionX, RegionY, RegionZ, Depth, LoadingBatch, BatchSize){\r\n    const VerticalIdentifier = RegionX + \",\" + RegionZ + \",\" + Depth;\r\n\r\n    const HeightMap = this.HeightMaps[VerticalIdentifier];\r\n\r\n    if(!HeightMap){ //The heightmap was probably unloaded...\r\n      console.error(\"No heightmap!! Region generation might stall as a result...\");\r\n      return;\r\n    }\r\n\r\n    const LocalMin = RegionY * _Region_mjs__WEBPACK_IMPORTED_MODULE_0__.Region.Y_LENGTH * (2 ** (1 + Depth));\r\n    const LocalMax = (RegionY + 1) * _Region_mjs__WEBPACK_IMPORTED_MODULE_0__.Region.Y_LENGTH * (2 ** (1 + Depth));\r\n    //if(HeightMap.MinHeight > LocalMax + 69 || Math.max(HeightMap.MaxHeight, 10) < LocalMin - 169) return; //TODO: Properly unload the region!\r\n    //^^ Discard virtual regions that are too far away from the heightmap. The large buffer zone\r\n    //is to account for objects independent of the heightmap, e.g. trees (-169) or craters (+69).\r\n    //The Math.max is there to ensure that ocean water is loaded.\r\n\r\n    this.WorkerRegionGenerator.postMessage({\r\n      \"Request\": \"GenerateVirtualRegionData\",\r\n      \"RegionX\": RegionX,\r\n      \"RegionY\": RegionY,\r\n      \"RegionZ\": RegionZ,\r\n      \"Depth\": Depth,\r\n      \"HeightMap\": HeightMap.HeightMap,\r\n      \"SlopeMap\": HeightMap.SlopeMap,\r\n      \"TemperatureMap\": HeightMap.TemperatureMap,\r\n      \"MaxHeight\": HeightMap.MaxHeight,\r\n      \"MinHeight\": HeightMap.MinHeight,\r\n      \"LoadingBatch\": LoadingBatch,\r\n      \"BatchSize\": BatchSize\r\n    });\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/LoadManager/RegionLoader.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/LoadManager/RegionUnloader.mjs":
/*!**********************************************************!*\
  !*** ./VoxelEngine/World/LoadManager/RegionUnloader.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RegionUnloader)\n/* harmony export */ });\n/* harmony import */ var _RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../RegionSD.mjs */ \"./VoxelEngine/World/RegionSD.mjs\");\n/* harmony import */ var _RequiredRegionsSelectionSD_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RequiredRegionsSelectionSD.mjs */ \"./VoxelEngine/World/LoadManager/RequiredRegionsSelectionSD.mjs\");\n\n\nclass RegionUnloader{\n  //WARNING: Outdated code\n  /*constructor(LoadManager){\n    this.LoadManager = LoadManager;\n    this.Data64 = LoadManager.Data64;\n    this.Data8 = LoadManager.Data8;\n    this.AllocationIndex64 = LoadManager.AllocationIndex64;\n    this.AllocationIndex = LoadManager.AllocationIndex;\n    this.AllocationArray64 = LoadManager.AllocationArray64;\n    this.AllocationArray = LoadManager.AllocationArray;\n\n    void function Load(){\n      return;\n      self.setTimeout(Load.bind(this), 10);\n      this.UnloadRegions();\n    }.bind(this)();\n  }\n  UnloadData64(x64, y64, z64){\n    const Index64 = (x64 << 6) | (y64 << 3) | z64;\n    if(((this.Data64[Index64] >> 1) & 1) === 1 || ((this.Data64[Index64] >> 17) & 1) === 1) return; //Is all air or is unloadable\n    const DeallocIndex = Atomics.add(this.AllocationIndex64, 1, 1) & 4095; //Indexing 1 for deallocation.\n    const Location64 = this.Data64[Index64] & 0x0fff;\n    for(let i = 0; i < 512; ++i) this.DeallocateData8((Location64 << 9) | i)\n    Atomics.store(this.AllocationArray64, DeallocIndex, Location64); //Add location back to the allocation array to be reused.\n    this.Data64[(x64 << 6) | (y64 << 3) | z64] &=~0b1000111111111111; //Reset previous location and existence marker.\n    this.Data64[(x64 << 6) | (y64 << 3) | z64] |=0b11000000000000000; //Set unloaded and inexistence markers.\n  }\n  DeallocateData8(Index8){\n    const Location = this.Data8[Index8];\n    if((Location & 0x80000000) !== 0) return;\n    if((Location & 0x10000000) === 0){ //Doesn't have uniform type, so has to deallocate Data1 and VoxelTypes memory\n      const DeallocIndex = Atomics.add(this.AllocationIndex, 1, 1) & (this.AllocationArray.length - 1);\n      Atomics.store(this.AllocationArray, DeallocIndex, Location);\n    }\n    this.Data8[Index8] = 0x80000000;\n  }\n  UnloadRegions(){\n    const Data64 = this.LoadManager.Data64;\n    const Data8 = this.LoadManager.Data8;\n    const Data1 = this.LoadManager.Data1;\n    for(let Depth = 0; Depth < 8; ++Depth) for(let x64 = 0; x64 < 8; ++x64) for(let y64 = 0; y64 < 8; ++y64) Iterator: for(let z64 = 0; z64 < 8; ++z64){\n      if(Depth === 0 && (x64 === 0 || y64 === 0 || z64 === 0 || x64 === 7 || y64 === 7 || z64 === 7)) continue;\n      const Index64 = (Depth << 9 ) | (x64 << 6) | (y64 << 3) | z64;\n      const Info64 = Data64[Index64];\n      //Has not fully been loaded, or is completely empty, or is already unloaded, or is unloadable\n      if(((Info64 >> 19) & 7) < 7 || ((Info64 >> 15) & 1) === 1 || ((Info64 >> 16) & 1) === 1 || ((Info64 >> 17) & 1) === 1) continue;\n      for(const [dx64, dy64, dz64] of [\n        [x64, y64, z64],\n        [x64 - 1, y64, z64],\n        [x64 + 1, y64, z64],\n        [x64, y64 - 1, z64],\n        [x64, y64 + 1, z64],\n        [x64, y64, z64 - 1],\n        [x64, y64, z64 + 1]\n      ]){\n        const dIndex64 = (Depth << 9) | (dx64 << 6) | (dy64 << 3) | dz64;\n        const dInfo64 = Data64[dIndex64];\n        if(((dInfo64 >> 19) & 7) < 2) continue Iterator;\n        if(((dInfo64 >> 16) & 1) === 1) continue;\n        if(((dInfo64 >> 15) & 1) === 1){\n          Data64[Index64] |= 1 << 17; //I already know that Index64 isn't fully air, so this is fine.\n          continue Iterator;\n        }\n        const dLocation64 = dInfo64 & 0x0fff;\n        for(let i = 0; i < 512; ++i){\n          const dInfo8 = Data8[(dLocation64 << 9) | i];\n          if((dInfo8 >> 31) === 1) continue Iterator;\n          if(((dInfo8 >> 28) & 1) === 1) continue Iterator; //TODO: Check if the type is actually solid (might be water or something)\n          const dLocation8 = dInfo8 & 0x00ffffff;\n          for(let j = 0; j < 64; ++j){\n            if(Data1[(dLocation8 << 6) | j] !== 0){\n              Data64[dIndex64] |= 1 << 17; //Make unloadable\n              continue Iterator;\n            }\n          }\n        }\n      }\n      this.UnloadData64(x64, y64, z64);\n    }\n  }*/\n};\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/LoadManager/RegionUnloader.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/LoadManager/RequiredRegionsSelectionSD.mjs":
/*!**********************************************************************!*\
  !*** ./VoxelEngine/World/LoadManager/RequiredRegionsSelectionSD.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst RequiredRegionsSelectionSD = {\r\n  \"DEPTH\": 0,\r\n  \"IN_X1\": 1,\r\n  \"IN_Y1\": 2,\r\n  \"IN_Z1\": 3,\r\n  \"IN_X2\": 4,\r\n  \"IN_Y2\": 5,\r\n  \"IN_Z2\": 6,\r\n  \"EX_X1\": 7,\r\n  \"EX_Y1\": 8,\r\n  \"EX_Z1\": 9,\r\n  \"EX_X2\": 10,\r\n  \"EX_Y2\": 11,\r\n  \"EX_Z2\": 12\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RequiredRegionsSelectionSD);\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/LoadManager/RequiredRegionsSelectionSD.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/Region.mjs":
/*!**************************************!*\
  !*** ./VoxelEngine/World/Region.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Region\": () => (/* binding */ Region),\n/* harmony export */   \"VirtualRegion\": () => (/* binding */ VirtualRegion)\n/* harmony export */ });\n/* harmony import */ var _RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegionSD.mjs */ \"./VoxelEngine/World/RegionSD.mjs\");\n\r\nclass Region{\r\n  static Version = \"Alpha 0.1.4.16\";\r\n  static Build = 33;\r\n\r\n  static X_LENGTH = 32;\r\n  static X_POWER = 5;\r\n  static X_LENGTH_SQUARED = 1024;\r\n  static X_LENGTH_MINUS_ONE = 31;\r\n\r\n  static Y_LENGTH = 64;\r\n  static Y_POWER = 6;\r\n  static Y_LENGTH_SQUARED = 4096;\r\n  static Y_LENGTH_MINUS_ONE = 63;\r\n\r\n  static Z_LENGTH = 32;\r\n  static Z_POWER = 5;\r\n  static Z_LENGTH_SQUARED = 1024;\r\n  static Z_LENGTH_MINUS_ONE = 31;\r\n\r\n  constructor(SharedData, RegionData, RegionX, RegionY, RegionZ){\r\n    this.SharedData = SharedData;\r\n    this.RegionData = RegionData;\r\n\r\n    this.RegionX = RegionX;\r\n    this.RegionY = RegionY;\r\n    this.RegionZ = RegionZ;\r\n\r\n    this.ThreadSafeTime = self.performance.now();\r\n\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REQUEST_TIME] = this.ThreadSafeTime;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UNLOAD_TIME] = -Infinity;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REGION_X] = RegionX;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REGION_Y] = RegionY;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REGION_Z] = RegionZ;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DEPTH] = -1;\r\n  }\r\n\r\n  GetIdentifier(){\r\n    return this.RegionX + \",\" + this.RegionY + \",\" + this.RegionZ;\r\n  }\r\n\r\n  Init(RegionData, CommonBlock, IsEntirelySolid){\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOADED] = 1;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK] = CommonBlock ?? -1;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IS_ENTIRELY_SOLID] = IsEntirelySolid | 0;\r\n\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_REQUIRED] = 1;\r\n\r\n    if(!CommonBlock || this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DEPTH] !== -1){\r\n      this.RegionData = RegionData;\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 1;\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].REVERSE_DATA_ACKNOWLEDGED] = 1;\r\n      return true;\r\n    } else{\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 0;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  Destruct(){\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UNLOAD_TIME] = self.performance.now();\r\n\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOADED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DATA_ATTACHED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_REQUIRED] = 0;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_UPDATE_REQUIRED] = 0;\r\n\r\n    this.RegionData = undefined;\r\n  }\r\n\r\n  SetBlock(rX, rY, rZ, BlockID){\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_REQUIRED] = 1;\r\n    this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GD_UPDATE_REQUIRED] = 1;\r\n\r\n    if(this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IS_ENTIRELY_SOLID] === 1 && BlockID === 0){\r\n      this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IS_ENTIRELY_SOLID] = 0;\r\n    }\r\n\r\n    let NewlyCreatedData = false;\r\n    if(!this.RegionData){\r\n      this.RegionData = new Uint16Array(new SharedArrayBuffer(Region.X_LENGTH * Region.Y_LENGTH * Region.Z_LENGTH * 2));\r\n      NewlyCreatedData = true;\r\n    }\r\n\r\n    if(this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK] !== -1){\r\n      if(NewlyCreatedData) this.RegionData.set(this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK]);\r\n\r\n      if(BlockID !== this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK]) this.SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].COMMON_BLOCK] = -1;\r\n    }\r\n    this.Data[rX * Region.Z_LENGTH * Region.Y_LENGTH + rY * Region.Z_LENGTH + rZ] = BlockID;\r\n    return NewlyCreatedData;\r\n  }\r\n}\r\n\r\nclass VirtualRegion extends Region{\r\n  constructor(SharedData, RegionData, RegionX, RegionY, RegionZ, Depth){\r\n    SharedData[_RegionSD_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DEPTH] = Depth;\r\n    super(SharedData, RegionData, RegionX, RegionY, RegionZ);\r\n    this.Depth = Depth;\r\n  }\r\n}\r\n/*\r\nexport class MicroRegion extends Region{\r\n\r\n  static X_LENGTH = 16;\r\n  static X_POWER = 4;\r\n  static X_LENGTH_SQUARED = 256;\r\n  static X_LENGTH_MINUS_ONE = 15;\r\n\r\n  static Y_LENGTH = 16;\r\n  static Y_POWER = 4;\r\n  static Y_LENGTH_SQUARED = 256;\r\n  static Y_LENGTH_MINUS_ONE = 15;\r\n\r\n  static Z_LENGTH = 16;\r\n  static Z_POWER = 4;\r\n  static Z_LENGTH_SQUARED = 256;\r\n  static Z_LENGTH_MINUS_ONE = 15;\r\n\r\n  constructor(RegionX, RegionY, RegionZ){\r\n    super(RegionX, RegionY, RegionZ);\r\n  }\r\n}*/\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/Region.mjs?");

/***/ }),

/***/ "./VoxelEngine/World/RegionSD.mjs":
/*!****************************************!*\
  !*** ./VoxelEngine/World/RegionSD.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst REGION_SD = {\r\n  \"REQUEST_TIME\": 0,\r\n\r\n  \"UNLOAD_TIME\": 1,\r\n  \"DATA_ATTACHED\": 2,\r\n\r\n  \"MAIN_THREAD_RECEIVED\": 3,\r\n  \"LOADED\": 4,\r\n  \"LOAD_ACKNOWLEDGED\": 5,\r\n  \"GD_REQUIRED\": 6,\r\n  \"GD_UPDATE_REQUIRED\": 7,\r\n  \"REVERSE_DATA_ACKNOWLEDGED\": 8,\r\n\r\n  \"REGION_X\": 9,\r\n  \"REGION_Y\": 10,\r\n  \"REGION_Z\": 11,\r\n  \"DEPTH\": 12,\r\n\r\n  \"IS_ENTIRELY_SOLID\": 13,\r\n  \"COMMON_BLOCK\": 14,\r\n\r\n  \"LOADING_STAGE\": 15,\r\n\r\n  \"BUFFER_SIZE\": 16 * 8\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (REGION_SD);\r\n\n\n//# sourceURL=webpack://ElectronProject/./VoxelEngine/World/RegionSD.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".Bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"VoxelEngine_BackgroundTasks_WorkerLoadingPipeline_mjs": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./VoxelEngine/BackgroundTasks/WorkerLoadingPipeline.mjs");
/******/ 	
/******/ })()
;