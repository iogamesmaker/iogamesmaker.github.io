(()=>{"use strict";class t{constructor(t,e,s=-1){this.Identifier=t,this.Properties=e,this.ID=s}}class e{static MAX_BLOCK_IDS=65536;constructor(){this.BlockIDMapping={},this.BlockIdentifierMapping={},this.RegisterPrimaryIDs()}static Initialise(t,e){let s=Object.create(this.prototype);return s.BlockIDMapping=t,s.BlockIdentifierMapping=e,s}RegisterPrimaryIDs(){this.RegisterBlock(new t("primary:air",{Solid:!1,Invisible:!0,Transparent:!0,Precedence:-32},0),0),this.RegisterBlock(new t("primary:not_loaded",{Solid:!0,Invisible:!0,Transparent:!0},49148),49148),this.RegisterBlock(new t("primary:placeholder",{Solid:!0,Invisible:!1,Transparent:!1},49149),49149),this.RegisterBlock(new t("primary:temp",{Solid:!0,Invisible:!1,Transparent:!1},49150),49150),this.RegisterBlock(new t("primary:error",{Solid:!0,Invisible:!1,Transparent:!1,Precedence:1/0},49151),49151),this.RegisterBlock(new t("primary:custom",{Solid:!0,Invisible:!1,Transparent:!1,Precedence:1024},65535),65535),this.RegisterBlock(new t("generic:solid",{Solid:!0,Invisible:!1,Transparent:!1},61440),61440),this.RegisterBlock(new t("generic:gas",{Solid:!1,Invisible:!0,Transparent:!0},61441),61441),this.RegisterBlock(new t("generic:fluid",{Solid:!1,Invisible:!1,Transparent:!0},61442),61442)}RegisterBlock(t,s){if(void 0!==s){if(s<0||s>=e.MAX_BLOCK_IDS)throw new Error("Invalid Block ID.");if(void 0!==this.BlockIDMapping[s])throw new Error("The Block ID "+s+" has already been mapped to a block ("+this.GetBlockByID(s).Identifier+"). Try not specifying the ID to ensure that the block is given a unique Block ID.")}else s=this.FindSmallestID();this.BlockIDMapping[s]=t,this.BlockIdentifierMapping[t.Identifier]=t,t.ID=s}GetBlockByID(t){return this.BlockIDMapping[t]??this.BlockIDMapping[49151]}GetBlockByIdentifier(t){return this.BlockIdentifierMapping[t]??this.BlockIDMapping[49151]}FindSmallestID(){for(let t=0;t<e.MAX_BLOCK_IDS;t++)if(void 0===this.BlockIDMapping[t])return t}}class s{constructor(t,e=i.INTERPOLATION_NEAREST_NEIGHBOUR,s=null){this.Scales=t,this.InterpolationMethod=e,this.BlockRegistry=s}GetScale(t,e=null){if(this.Scales[t])return this.Scales[t];const s=e||this.BlockRegistry;if(!s)throw new Error("Scale Containers need access to a block registry to calculate smaller scales.");const i=this.Scales[1],n=i.Data,o=this.Scales[1].XLength,r=this.Scales[1].YLength,a=this.Scales[1].ZLength,l=Math.ceil(o/t),c=Math.ceil(r/t),f=Math.ceil(a/t),h=new Uint16Array(l*c*f);for(let e=0,i=0;e<l;e++)for(let l=0;l<c;l++)for(let c=0;c<f;c++,i++){const f=Math.floor(e*t),g=Math.floor(l*t),u=Math.floor(c*t);let p=0,S=-1/0;for(let e=f;e<t+f&&e<o;e++)for(let i=g;i<t+g&&i<r;i++)for(let o=u;o<t+u&&o<a;o++){const t=n[e*r*a+i*a+o],l=s.GetBlockByID(t).Properties.Precedence||0;(S<l||6===t)&&(S=l,p=t)}h[i]=p}return this.Scales[t]={XOffset:Math.floor(i.XOffset/t),YOffset:Math.floor(i.YOffset/t),ZOffset:Math.floor(i.ZOffset/t),XLength:l,YLength:c,ZLength:f,Data:h},this.Scales[t]}GetScale_NearestNeighbour(t){if(this.Scales[t])return this.Scales[t];const e=this.Scales[1],s=e.Data,i=this.Scales[1].XLength,n=this.Scales[1].YLength,o=this.Scales[1].ZLength,r=Math.ceil(i/t),a=Math.ceil(n/t),l=Math.ceil(o/t),c=new Uint16Array(r*a*l);for(let e=0,i=0;e<r;e++)for(let r=0;r<a;r++)for(let a=0;a<l;a++,i++){const l=Math.floor(e*t),f=Math.floor(r*t),h=Math.floor(a*t);c[i]=s[l*n*o+f*o+h]}return this.Scales[t]={XOffset:Math.floor(e.XOffset/t),YOffset:Math.floor(e.YOffset/t),ZOffset:Math.floor(e.ZOffset/t),XLength:r,YLength:a,ZLength:l,Data:c},this.Scales[t]}GetVerticalScale(t){if(this.Scales["Y"+t])return this.Scales["Y"+t];const e=this.Scales[1],s=e.Data,i=this.Scales[1].XLength,n=this.Scales[1].YLength,o=this.Scales[1].ZLength,r=Math.ceil(n/t),a=new Uint16Array(i*r*o);for(let e=0,l=0;e<i;e++)for(let i=0;i<r;i++)for(let r=0;r<o;r++,l++){const c=e,f=Math.floor(i*t),h=r;let g=0;for(let e=f;e<n&&e<f+t;e++)g||=s[c*n*o+e*o+h];a[l]=g}return this.Scales["Y"+t]={XOffset:e.XOffset,YOffset:Math.floor(e.YOffset/t),ZOffset:e.ZOffset,XLength:i,YLength:r,ZLength:o,Data:a},this.Scales["Y"+t]}_GetVerticalScale(t){if(this.Scales["Y"+t])return this.Scales["Y"+t];const e=this.Scales[1],s=e.Data,i=this.Scales[1].XLength,n=this.Scales[1].YLength,o=this.Scales[1].ZLength,r=Math.ceil(n/t),a=new Uint16Array(i*r*o);for(let e=0,l=0;e<i;e++)for(let i=0;i<r;i++)for(let r=0;r<o;r++,l++){const c=e,f=Math.floor(i*t),h=r;a[l]=s[c*n*o+f*o+h]}return this.Scales["Y"+t]={XOffset:e.XOffset,YOffset:Math.floor(e.YOffset/t),ZOffset:e.ZOffset,XLength:i,YLength:r,ZLength:o,Data:a},this.Scales["Y"+t]}}class i{static INTERPOLATION_NEAREST_NEIGHBOUR=1;static INTERPOLATION_HIGHEST_FREQUENCY=2;static INTERPOLATION_COMMON_BLOCKS=3;constructor(t,e=null,s={}){this.Scales=t,this.Metadata=e,this.Info=s}DirectPaste(t,e,s,i,n,o,r=!1){const a=this.Scales.GetScale(i,n),l=t+a.XOffset,c=e+a.YOffset,f=s+a.ZOffset,h=a.Data;for(let t=l,e=a.XLength+l,s=0;t<e;t++)for(let e=c,i=a.YLength+c;e<i;e++)for(let i=f,n=a.ZLength+f;i<n;i++,s++)r&&0===h[s]||o(t,e,i,h[s])}static FromObject(t){const e={};return Object.assign(e,t),Object.setPrototypeOf(e,i.prototype),Object.setPrototypeOf(e.Scales,s.prototype),e}}class n extends Error{constructor(){super("Ran out of Data8 memory."),this.name="NoData8Exception"}}let o=0,r=0,a=0;function l(t,e,s){let i=(4095&t)<<20|(255&e)<<12|4095&s;return i=73244475*(i>>>16^i),i=73244475*(i>>>16^i),i^=i>>>16,i/4294967295+.5}self.gc&&function t(){self.setTimeout(t,1e3),o-r>2e3&&o-a<4&&(self.gc(),r=o),a=o}();const c={};let f,h,g,u;self.onmessage=function(t){c[t.data.Request]?.(t.data)};let p,S,I,d,M,O,D,B,R,k=[];const y=new Uint8Array(64).fill(255),L=new Uint16Array(512);function m(t,e,s,i){const o=Atomics.add(M,0,1)&O.length-1,r=Atomics.exchange(O,o,2147483647);if(2147483647===r)throw Atomics.sub(M,0,1),new n;return I[t<<9|e<<6|s<<3|i]=1073741824|r,S.set(y,r<<6),p.set(L,r<<9),r}c.InitialiseBlockRegistry=function(t){f=e.Initialise(t.BlockIDMapping,t.BlockIdentifierMapping)},c.TransferRequiredRegionsArray=function(t){h=t.RequiredRegions},c.ShareQueueSize=function(t){g=t.OwnQueueSize},c.SaveDistancedPointMap=function(t){u=t.DistancedPointMap,console.log(u)},c.ShareDataBuffers=function(t){p=t.VoxelTypes,S=t.Data1,I=t.Data8,d=t.Data64,M=t.AllocationIndex,O=t.AllocationArray,D=t.AllocationIndex64,B=t.AllocationArray64,R=t.Data64Offset},c.ShareStructures=function(t){for(const e of t.Structures)e.Selection=i.FromObject(e.Selection),k.push(e)},c.DecorateRegion=function(t){const e=t.RegionX,s=t.RegionY,i=t.RegionZ,r=e-R[0],a=s-R[1],c=i-R[2];(r<0||r>7||a<0||a>7||c<0||c>7)&&console.warn("Generating out of bounds!!"),o++;const f=r<<6|a<<3|c,h=new Set([f]);d[f]&=~(1<<30);const M=function(t,e,s,i){if(0===i)return;const o=r+(t>>6),l=a+(e>>6),f=c+(s>>6),u=o<<6|l<<3|f;h.add(u);let M=d[u],O=524287&M;1==(M>>31&1)&&(O=function(t,e,s){const i=4095&Atomics.add(D,0,1),n=Atomics.exchange(B,i,65535),o=t<<6|e<<3|s;return d[o]&=~(1<<31),d[o]&=-524288,d[o]|=n,d[o]|=1<<30,n}(o,l,f)),d[u]|=1<<30,d[u]&=~(1<<31);const R=O<<9|(t>>3&7)<<6|(e>>3&7)<<3|s>>3&7;let k=I[R];try{if(1==(k>>31&1))k=m(O,t>>3&7,e>>3&7,s>>3&7);else if(1==(k>>28&1)){const i=65535&k;k=m(O,t>>3&7,e>>3&7,s>>3&7);const n=268435455&k;for(let t=0;t<512;++t)p[n<<9|t]=i;for(let t=0;t<64;++t)S[n<<6|t]=0}}catch(t){if(t instanceof n)return console.error("Ran out of Data8 while decorating region."),g&&Atomics.sub(g,0,1),self.postMessage({Request:"NoData8"});throw t}const y=268435455&k;I[R]|=1<<30;const L=y<<6|(7&t)<<3|7&e;S[L]&=~(1<<(7&s)),p[L<<3|7&s]=i},O=u[6][8*(7&e)+(7&i)];for(const{X:n,Z:o}of O){const r=Math.floor(t.Maps.HeightMap[64*n+o]),a=t.Maps.TemperatureMap[64*n+o],c=t.Maps.SlopeMap[64*n+o],f=l(n+64*e,0,o+64*i),h=l(n+64*e,3,o+64*i);if(64*(s+1)>r&&r>=64*s){if(f>a/2)continue;if(r<0)continue;if(h<r/1e3||2*h<c)continue;const t=r-64*s,g=l(n+64*e,1,o+64*i)*k.length>>0;k[g].Selection.DirectPaste(n,t,o,1,null,M)}}d[f]=-3670017&d[f]|7<<19;for(const t of h)d[t]|=1<<30,d[t]&=~(1<<29);g&&Atomics.sub(g,0,1),self.postMessage({Request:"Finished",RegionX:e,RegionY:s,RegionZ:i})}})();